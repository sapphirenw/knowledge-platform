// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const clearConversation = `-- name: ClearConversation :exec
DELETE FROM conversation_message
WHERE conversation_id = $1
`

// ClearConversation
//
//	DELETE FROM conversation_message
//	WHERE conversation_id = $1
func (q *Queries) ClearConversation(ctx context.Context, conversationID uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearConversation, conversationID)
	return err
}

const createBetaApiKey = `-- name: CreateBetaApiKey :one
INSERT INTO beta_api_key ( name )
VALUES ( $1 )
RETURNING id, name, expired, created_at, updated_at
`

// CreateBetaApiKey
//
//	INSERT INTO beta_api_key ( name )
//	VALUES ( $1 )
//	RETURNING id, name, expired, created_at, updated_at
func (q *Queries) CreateBetaApiKey(ctx context.Context, name string) (*BetaApiKey, error) {
	row := q.db.QueryRow(ctx, createBetaApiKey, name)
	var i BetaApiKey
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Expired,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversation (
    customer_id, title, conversation_type, system_message, metadata
) VALUES ( $1, $2, $3, $4, $5 )
RETURNING id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at
`

type CreateConversationParams struct {
	CustomerID       uuid.UUID `db:"customer_id" json:"customerId"`
	Title            string    `db:"title" json:"title"`
	ConversationType string    `db:"conversation_type" json:"conversationType"`
	SystemMessage    string    `db:"system_message" json:"systemMessage"`
	Metadata         []byte    `db:"metadata" json:"metadata"`
}

// CreateConversation
//
//	INSERT INTO conversation (
//	    customer_id, title, conversation_type, system_message, metadata
//	) VALUES ( $1, $2, $3, $4, $5 )
//	RETURNING id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at
func (q *Queries) CreateConversation(ctx context.Context, arg *CreateConversationParams) (*Conversation, error) {
	row := q.db.QueryRow(ctx, createConversation,
		arg.CustomerID,
		arg.Title,
		arg.ConversationType,
		arg.SystemMessage,
		arg.Metadata,
	)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.ConversationType,
		&i.SystemMessage,
		&i.Metadata,
		&i.HasError,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createConversationMessage = `-- name: CreateConversationMessage :one
INSERT INTO conversation_message (
    conversation_id,
    llm_id,
    model,
    temperature,
    instructions,
    role,
    message,
    index,
    tool_use_id,
    tool_name,
    tool_arguments,
    tool_results
) VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 )
ON CONFLICT (conversation_id, index)
DO UPDATE SET
    updated_at = CURRENT_TIMESTAMP
RETURNING id, conversation_id, llm_id, model, temperature, instructions, role, message, index, tool_use_id, tool_name, tool_arguments, tool_results, created_at, updated_at
`

type CreateConversationMessageParams struct {
	ConversationID uuid.UUID   `db:"conversation_id" json:"conversationId"`
	LlmID          pgtype.UUID `db:"llm_id" json:"llmId"`
	Model          string      `db:"model" json:"model"`
	Temperature    float64     `db:"temperature" json:"temperature"`
	Instructions   string      `db:"instructions" json:"instructions"`
	Role           string      `db:"role" json:"role"`
	Message        string      `db:"message" json:"message"`
	Index          int32       `db:"index" json:"index"`
	ToolUseID      string      `db:"tool_use_id" json:"toolUseId"`
	ToolName       string      `db:"tool_name" json:"toolName"`
	ToolArguments  []byte      `db:"tool_arguments" json:"toolArguments"`
	ToolResults    []byte      `db:"tool_results" json:"toolResults"`
}

// CreateConversationMessage
//
//	INSERT INTO conversation_message (
//	    conversation_id,
//	    llm_id,
//	    model,
//	    temperature,
//	    instructions,
//	    role,
//	    message,
//	    index,
//	    tool_use_id,
//	    tool_name,
//	    tool_arguments,
//	    tool_results
//	) VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 )
//	ON CONFLICT (conversation_id, index)
//	DO UPDATE SET
//	    updated_at = CURRENT_TIMESTAMP
//	RETURNING id, conversation_id, llm_id, model, temperature, instructions, role, message, index, tool_use_id, tool_name, tool_arguments, tool_results, created_at, updated_at
func (q *Queries) CreateConversationMessage(ctx context.Context, arg *CreateConversationMessageParams) (*ConversationMessage, error) {
	row := q.db.QueryRow(ctx, createConversationMessage,
		arg.ConversationID,
		arg.LlmID,
		arg.Model,
		arg.Temperature,
		arg.Instructions,
		arg.Role,
		arg.Message,
		arg.Index,
		arg.ToolUseID,
		arg.ToolName,
		arg.ToolArguments,
		arg.ToolResults,
	)
	var i ConversationMessage
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.LlmID,
		&i.Model,
		&i.Temperature,
		&i.Instructions,
		&i.Role,
		&i.Message,
		&i.Index,
		&i.ToolUseID,
		&i.ToolName,
		&i.ToolArguments,
		&i.ToolResults,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customer (
    name
) VALUES (
    $1
)
RETURNING id, name, datastore, created_at, updated_at
`

// CreateCustomer
//
//	INSERT INTO customer (
//	    name
//	) VALUES (
//	    $1
//	)
//	RETURNING id, name, datastore, created_at, updated_at
func (q *Queries) CreateCustomer(ctx context.Context, name string) (*Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer, name)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Datastore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createDocument = `-- name: CreateDocument :one
INSERT INTO document (
    parent_id, customer_id, filename, type, size_bytes, sha_256, datastore_type, datastore_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (customer_id, parent_id, filename) DO UPDATE
SET updated_at = CURRENT_TIMESTAMP
RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at
`

type CreateDocumentParams struct {
	ParentID      pgtype.UUID `db:"parent_id" json:"parentId"`
	CustomerID    uuid.UUID   `db:"customer_id" json:"customerId"`
	Filename      string      `db:"filename" json:"filename"`
	Type          string      `db:"type" json:"type"`
	SizeBytes     int64       `db:"size_bytes" json:"sizeBytes"`
	Sha256        string      `db:"sha_256" json:"sha256"`
	DatastoreType string      `db:"datastore_type" json:"datastoreType"`
	DatastoreID   string      `db:"datastore_id" json:"datastoreId"`
}

// CreateDocument
//
//	INSERT INTO document (
//	    parent_id, customer_id, filename, type, size_bytes, sha_256, datastore_type, datastore_id
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8
//	)
//	ON CONFLICT (customer_id, parent_id, filename) DO UPDATE
//	SET updated_at = CURRENT_TIMESTAMP
//	RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at
func (q *Queries) CreateDocument(ctx context.Context, arg *CreateDocumentParams) (*Document, error) {
	row := q.db.QueryRow(ctx, createDocument,
		arg.ParentID,
		arg.CustomerID,
		arg.Filename,
		arg.Type,
		arg.SizeBytes,
		arg.Sha256,
		arg.DatastoreType,
		arg.DatastoreID,
	)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Filename,
		&i.Type,
		&i.SizeBytes,
		&i.Sha256,
		&i.Validated,
		&i.DatastoreType,
		&i.DatastoreID,
		&i.Summary,
		&i.SummarySha256,
		&i.VectorSha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createDocumentVector = `-- name: CreateDocumentVector :one
INSERT INTO document_vector (
    document_id, vector_store_id, customer_id, index, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, document_id, vector_store_id, customer_id, index, metadata, created_at
`

type CreateDocumentVectorParams struct {
	DocumentID    uuid.UUID `db:"document_id" json:"documentId"`
	VectorStoreID uuid.UUID `db:"vector_store_id" json:"vectorStoreId"`
	CustomerID    uuid.UUID `db:"customer_id" json:"customerId"`
	Index         int32     `db:"index" json:"index"`
	Metadata      []byte    `db:"metadata" json:"metadata"`
}

// CreateDocumentVector
//
//	INSERT INTO document_vector (
//	    document_id, vector_store_id, customer_id, index, metadata
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	RETURNING id, document_id, vector_store_id, customer_id, index, metadata, created_at
func (q *Queries) CreateDocumentVector(ctx context.Context, arg *CreateDocumentVectorParams) (*DocumentVector, error) {
	row := q.db.QueryRow(ctx, createDocumentVector,
		arg.DocumentID,
		arg.VectorStoreID,
		arg.CustomerID,
		arg.Index,
		arg.Metadata,
	)
	var i DocumentVector
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.VectorStoreID,
		&i.CustomerID,
		&i.Index,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const createFolder = `-- name: CreateFolder :one
INSERT INTO folder (
    parent_id, customer_id, title
) VALUES (
    $1, $2, $3
)
ON CONFLICT (customer_id, parent_id, title) DO UPDATE
SET updated_at = CURRENT_TIMESTAMP
RETURNING id, parent_id, customer_id, title, created_at, updated_at
`

type CreateFolderParams struct {
	ParentID   pgtype.UUID `db:"parent_id" json:"parentId"`
	CustomerID uuid.UUID   `db:"customer_id" json:"customerId"`
	Title      string      `db:"title" json:"title"`
}

// CreateFolder
//
//	INSERT INTO folder (
//	    parent_id, customer_id, title
//	) VALUES (
//	    $1, $2, $3
//	)
//	ON CONFLICT (customer_id, parent_id, title) DO UPDATE
//	SET updated_at = CURRENT_TIMESTAMP
//	RETURNING id, parent_id, customer_id, title, created_at, updated_at
func (q *Queries) CreateFolder(ctx context.Context, arg *CreateFolderParams) (*Folder, error) {
	row := q.db.QueryRow(ctx, createFolder, arg.ParentID, arg.CustomerID, arg.Title)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createFolderRoot = `-- name: CreateFolderRoot :one
INSERT INTO folder (
    customer_id, title
) VALUES (
    $1, 'root'
)
ON CONFLICT (customer_id, parent_id, title) DO UPDATE
SET updated_at = CURRENT_TIMESTAMP
RETURNING id, parent_id, customer_id, title, created_at, updated_at
`

// CreateFolderRoot
//
//	INSERT INTO folder (
//	    customer_id, title
//	) VALUES (
//	    $1, 'root'
//	)
//	ON CONFLICT (customer_id, parent_id, title) DO UPDATE
//	SET updated_at = CURRENT_TIMESTAMP
//	RETURNING id, parent_id, customer_id, title, created_at, updated_at
func (q *Queries) CreateFolderRoot(ctx context.Context, customerID uuid.UUID) (*Folder, error) {
	row := q.db.QueryRow(ctx, createFolderRoot, customerID)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createLLM = `-- name: CreateLLM :one
INSERT INTO llm (
    customer_id, title, model, temperature, instructions, is_default
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at
`

type CreateLLMParams struct {
	CustomerID   pgtype.UUID `db:"customer_id" json:"customerId"`
	Title        string      `db:"title" json:"title"`
	Model        string      `db:"model" json:"model"`
	Temperature  float64     `db:"temperature" json:"temperature"`
	Instructions string      `db:"instructions" json:"instructions"`
	IsDefault    bool        `db:"is_default" json:"isDefault"`
}

// CreateLLM
//
//	INSERT INTO llm (
//	    customer_id, title, model, temperature, instructions, is_default
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6
//	)
//	RETURNING id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at
func (q *Queries) CreateLLM(ctx context.Context, arg *CreateLLMParams) (*Llm, error) {
	row := q.db.QueryRow(ctx, createLLM,
		arg.CustomerID,
		arg.Title,
		arg.Model,
		arg.Temperature,
		arg.Instructions,
		arg.IsDefault,
	)
	var i Llm
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Color,
		&i.Model,
		&i.Temperature,
		&i.Instructions,
		&i.IsDefault,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createLinkedInPost = `-- name: CreateLinkedInPost :one
INSERT INTO linkedin_post(
    project_id, project_library_id, project_idea_id, title
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at
`

type CreateLinkedInPostParams struct {
	ProjectID        uuid.UUID   `db:"project_id" json:"projectId"`
	ProjectLibraryID uuid.UUID   `db:"project_library_id" json:"projectLibraryId"`
	ProjectIdeaID    pgtype.UUID `db:"project_idea_id" json:"projectIdeaId"`
	Title            string      `db:"title" json:"title"`
}

// CreateLinkedInPost
//
//	INSERT INTO linkedin_post(
//	    project_id, project_library_id, project_idea_id, title
//	) VALUES (
//	    $1, $2, $3, $4
//	)
//	RETURNING id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at
func (q *Queries) CreateLinkedInPost(ctx context.Context, arg *CreateLinkedInPostParams) (*LinkedinPost, error) {
	row := q.db.QueryRow(ctx, createLinkedInPost,
		arg.ProjectID,
		arg.ProjectLibraryID,
		arg.ProjectIdeaID,
		arg.Title,
	)
	var i LinkedinPost
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectLibraryID,
		&i.ProjectIdeaID,
		&i.Title,
		&i.AssetID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createLinkedInPostConfig = `-- name: CreateLinkedInPostConfig :one
INSERT INTO linkedin_post_config (
    project_id, linkedin_post_id,
    min_sections, max_sections, num_documents, num_website_pages,
    llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (linkedin_post_id)
DO UPDATE SET
    min_sections = EXCLUDED.min_sections,
    max_sections = EXCLUDED.max_sections,
    num_documents = EXCLUDED.num_documents,
    num_website_pages = EXCLUDED.num_website_pages,
    llm_content_generation_id = EXCLUDED.llm_content_generation_id,
    llm_vector_summarization_id = EXCLUDED.llm_vector_summarization_id,
    llm_website_summarization_id = EXCLUDED.llm_website_summarization_id,
    llm_proof_reading_id = EXCLUDED.llm_proof_reading_id
RETURNING id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at
`

type CreateLinkedInPostConfigParams struct {
	ProjectID                 pgtype.UUID `db:"project_id" json:"projectId"`
	LinkedinPostID            pgtype.UUID `db:"linkedin_post_id" json:"linkedinPostId"`
	MinSections               int32       `db:"min_sections" json:"minSections"`
	MaxSections               int32       `db:"max_sections" json:"maxSections"`
	NumDocuments              int32       `db:"num_documents" json:"numDocuments"`
	NumWebsitePages           int32       `db:"num_website_pages" json:"numWebsitePages"`
	LlmContentGenerationID    pgtype.UUID `db:"llm_content_generation_id" json:"llmContentGenerationId"`
	LlmVectorSummarizationID  pgtype.UUID `db:"llm_vector_summarization_id" json:"llmVectorSummarizationId"`
	LlmWebsiteSummarizationID pgtype.UUID `db:"llm_website_summarization_id" json:"llmWebsiteSummarizationId"`
	LlmProofReadingID         pgtype.UUID `db:"llm_proof_reading_id" json:"llmProofReadingId"`
}

// CreateLinkedInPostConfig
//
//	INSERT INTO linkedin_post_config (
//	    project_id, linkedin_post_id,
//	    min_sections, max_sections, num_documents, num_website_pages,
//	    llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
//	)
//	ON CONFLICT (linkedin_post_id)
//	DO UPDATE SET
//	    min_sections = EXCLUDED.min_sections,
//	    max_sections = EXCLUDED.max_sections,
//	    num_documents = EXCLUDED.num_documents,
//	    num_website_pages = EXCLUDED.num_website_pages,
//	    llm_content_generation_id = EXCLUDED.llm_content_generation_id,
//	    llm_vector_summarization_id = EXCLUDED.llm_vector_summarization_id,
//	    llm_website_summarization_id = EXCLUDED.llm_website_summarization_id,
//	    llm_proof_reading_id = EXCLUDED.llm_proof_reading_id
//	RETURNING id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at
func (q *Queries) CreateLinkedInPostConfig(ctx context.Context, arg *CreateLinkedInPostConfigParams) (*LinkedinPostConfig, error) {
	row := q.db.QueryRow(ctx, createLinkedInPostConfig,
		arg.ProjectID,
		arg.LinkedinPostID,
		arg.MinSections,
		arg.MaxSections,
		arg.NumDocuments,
		arg.NumWebsitePages,
		arg.LlmContentGenerationID,
		arg.LlmVectorSummarizationID,
		arg.LlmWebsiteSummarizationID,
		arg.LlmProofReadingID,
	)
	var i LinkedinPostConfig
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.LinkedinPostID,
		&i.MinSections,
		&i.MaxSections,
		&i.NumDocuments,
		&i.NumWebsitePages,
		&i.LlmContentGenerationID,
		&i.LlmVectorSummarizationID,
		&i.LlmWebsiteSummarizationID,
		&i.LlmProofReadingID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO project (
    customer_id, title, topic, idea_generation_model_id
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at
`

type CreateProjectParams struct {
	CustomerID            uuid.UUID   `db:"customer_id" json:"customerId"`
	Title                 string      `db:"title" json:"title"`
	Topic                 string      `db:"topic" json:"topic"`
	IdeaGenerationModelID pgtype.UUID `db:"idea_generation_model_id" json:"ideaGenerationModelId"`
}

// CreateProject
//
//	INSERT INTO project (
//	    customer_id, title, topic, idea_generation_model_id
//	) VALUES (
//	    $1, $2, $3, $4
//	)
//	RETURNING id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at
func (q *Queries) CreateProject(ctx context.Context, arg *CreateProjectParams) (*Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.CustomerID,
		arg.Title,
		arg.Topic,
		arg.IdeaGenerationModelID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Topic,
		&i.IdeaGenerationModelID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createProjectIdea = `-- name: CreateProjectIdea :one
INSERT INTO project_idea (
    project_id, conversation_id, title, used
) VALUES (
    $1, $2, $3, FALSE
)
RETURNING id, project_id, conversation_id, title, used, created_at, updated_at
`

type CreateProjectIdeaParams struct {
	ProjectID      uuid.UUID   `db:"project_id" json:"projectId"`
	ConversationID pgtype.UUID `db:"conversation_id" json:"conversationId"`
	Title          string      `db:"title" json:"title"`
}

// CreateProjectIdea
//
//	INSERT INTO project_idea (
//	    project_id, conversation_id, title, used
//	) VALUES (
//	    $1, $2, $3, FALSE
//	)
//	RETURNING id, project_id, conversation_id, title, used, created_at, updated_at
func (q *Queries) CreateProjectIdea(ctx context.Context, arg *CreateProjectIdeaParams) (*ProjectIdea, error) {
	row := q.db.QueryRow(ctx, createProjectIdea, arg.ProjectID, arg.ConversationID, arg.Title)
	var i ProjectIdea
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConversationID,
		&i.Title,
		&i.Used,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createProjectLibraryRecord = `-- name: CreateProjectLibraryRecord :one
INSERT INTO project_library (
    project_id, title, content_type
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, title, content_type, draft, published, created_at, updated_at
`

type CreateProjectLibraryRecordParams struct {
	ProjectID   uuid.UUID `db:"project_id" json:"projectId"`
	Title       string    `db:"title" json:"title"`
	ContentType string    `db:"content_type" json:"contentType"`
}

// CreateProjectLibraryRecord
//
//	INSERT INTO project_library (
//	    project_id, title, content_type
//	) VALUES (
//	    $1, $2, $3
//	)
//	RETURNING id, project_id, title, content_type, draft, published, created_at, updated_at
func (q *Queries) CreateProjectLibraryRecord(ctx context.Context, arg *CreateProjectLibraryRecordParams) (*ProjectLibrary, error) {
	row := q.db.QueryRow(ctx, createProjectLibraryRecord, arg.ProjectID, arg.Title, arg.ContentType)
	var i ProjectLibrary
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.ContentType,
		&i.Draft,
		&i.Published,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createTokenUsage = `-- name: CreateTokenUsage :one
INSERT INTO token_usage (
    id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (id)
DO UPDATE SET
    customer_id = EXCLUDED.customer_id,
    conversation_id = EXCLUDED.conversation_id,
    model = EXCLUDED.model,
    input_tokens = EXCLUDED.input_tokens,
    output_tokens = EXCLUDED.output_tokens,
    total_tokens = EXCLUDED.total_tokens
RETURNING id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens, created_at
`

type CreateTokenUsageParams struct {
	ID             uuid.UUID   `db:"id" json:"id"`
	CustomerID     uuid.UUID   `db:"customer_id" json:"customerId"`
	ConversationID pgtype.UUID `db:"conversation_id" json:"conversationId"`
	Model          string      `db:"model" json:"model"`
	InputTokens    int32       `db:"input_tokens" json:"inputTokens"`
	OutputTokens   int32       `db:"output_tokens" json:"outputTokens"`
	TotalTokens    int32       `db:"total_tokens" json:"totalTokens"`
}

// CreateTokenUsage
//
//	INSERT INTO token_usage (
//	    id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7
//	)
//	ON CONFLICT (id)
//	DO UPDATE SET
//	    customer_id = EXCLUDED.customer_id,
//	    conversation_id = EXCLUDED.conversation_id,
//	    model = EXCLUDED.model,
//	    input_tokens = EXCLUDED.input_tokens,
//	    output_tokens = EXCLUDED.output_tokens,
//	    total_tokens = EXCLUDED.total_tokens
//	RETURNING id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens, created_at
func (q *Queries) CreateTokenUsage(ctx context.Context, arg *CreateTokenUsageParams) (*TokenUsage, error) {
	row := q.db.QueryRow(ctx, createTokenUsage,
		arg.ID,
		arg.CustomerID,
		arg.ConversationID,
		arg.Model,
		arg.InputTokens,
		arg.OutputTokens,
		arg.TotalTokens,
	)
	var i TokenUsage
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ConversationID,
		&i.Model,
		&i.InputTokens,
		&i.OutputTokens,
		&i.TotalTokens,
		&i.CreatedAt,
	)
	return &i, err
}

const createVector = `-- name: CreateVector :one
INSERT INTO vector_store (
    customer_id, raw, embeddings, content_type, object_id, object_parent_id, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id
`

type CreateVectorParams struct {
	CustomerID     uuid.UUID        `db:"customer_id" json:"customerId"`
	Raw            string           `db:"raw" json:"raw"`
	Embeddings     *pgvector.Vector `db:"embeddings" json:"embeddings"`
	ContentType    string           `db:"content_type" json:"contentType"`
	ObjectID       uuid.UUID        `db:"object_id" json:"objectId"`
	ObjectParentID pgtype.UUID      `db:"object_parent_id" json:"objectParentId"`
	Metadata       []byte           `db:"metadata" json:"metadata"`
}

// CreateVector
//
//	INSERT INTO vector_store (
//	    customer_id, raw, embeddings, content_type, object_id, object_parent_id, metadata
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7
//	)
//	RETURNING id
func (q *Queries) CreateVector(ctx context.Context, arg *CreateVectorParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createVector,
		arg.CustomerID,
		arg.Raw,
		arg.Embeddings,
		arg.ContentType,
		arg.ObjectID,
		arg.ObjectParentID,
		arg.Metadata,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createVectorizeJob = `-- name: CreateVectorizeJob :one
INSERT INTO vectorize_job (
    customer_id, documents, websites
) VALUES ( $1, $2, $3 )
RETURNING id, customer_id, documents, websites, created_at, updated_at
`

type CreateVectorizeJobParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	Documents  bool      `db:"documents" json:"documents"`
	Websites   bool      `db:"websites" json:"websites"`
}

// CreateVectorizeJob
//
//	INSERT INTO vectorize_job (
//	    customer_id, documents, websites
//	) VALUES ( $1, $2, $3 )
//	RETURNING id, customer_id, documents, websites, created_at, updated_at
func (q *Queries) CreateVectorizeJob(ctx context.Context, arg *CreateVectorizeJobParams) (*VectorizeJob, error) {
	row := q.db.QueryRow(ctx, createVectorizeJob, arg.CustomerID, arg.Documents, arg.Websites)
	var i VectorizeJob
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Documents,
		&i.Websites,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createVectorizeJobItem = `-- name: CreateVectorizeJobItem :one
INSERT INTO vectorize_job_item (
    job_id, status, message, error
) VALUES ( $1, $2, $3, $4 )
RETURNING id, job_id, status, message, error, created_at, updated_at
`

type CreateVectorizeJobItemParams struct {
	JobID   uuid.UUID          `db:"job_id" json:"jobId"`
	Status  VectorizeJobStatus `db:"status" json:"status"`
	Message string             `db:"message" json:"message"`
	Error   string             `db:"error" json:"error"`
}

// CreateVectorizeJobItem
//
//	INSERT INTO vectorize_job_item (
//	    job_id, status, message, error
//	) VALUES ( $1, $2, $3, $4 )
//	RETURNING id, job_id, status, message, error, created_at, updated_at
func (q *Queries) CreateVectorizeJobItem(ctx context.Context, arg *CreateVectorizeJobItemParams) (*VectorizeJobItem, error) {
	row := q.db.QueryRow(ctx, createVectorizeJobItem,
		arg.JobID,
		arg.Status,
		arg.Message,
		arg.Error,
	)
	var i VectorizeJobItem
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.Message,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createWebsite = `-- name: CreateWebsite :one
INSERT INTO website (
    customer_id, protocol, domain, blacklist, whitelist
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT ON CONSTRAINT cnst_unique_website
DO UPDATE SET
    updated_at = CURRENT_TIMESTAMP,
    blacklist = EXCLUDED.blacklist,
    whitelist = EXCLUDED.whitelist
RETURNING id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at
`

type CreateWebsiteParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	Protocol   string    `db:"protocol" json:"protocol"`
	Domain     string    `db:"domain" json:"domain"`
	Blacklist  []string  `db:"blacklist" json:"blacklist"`
	Whitelist  []string  `db:"whitelist" json:"whitelist"`
}

// CreateWebsite
//
//	INSERT INTO website (
//	    customer_id, protocol, domain, blacklist, whitelist
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	ON CONFLICT ON CONSTRAINT cnst_unique_website
//	DO UPDATE SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    blacklist = EXCLUDED.blacklist,
//	    whitelist = EXCLUDED.whitelist
//	RETURNING id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at
func (q *Queries) CreateWebsite(ctx context.Context, arg *CreateWebsiteParams) (*Website, error) {
	row := q.db.QueryRow(ctx, createWebsite,
		arg.CustomerID,
		arg.Protocol,
		arg.Domain,
		arg.Blacklist,
		arg.Whitelist,
	)
	var i Website
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Protocol,
		&i.Domain,
		&i.Blacklist,
		&i.Whitelist,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createWebsitePage = `-- name: CreateWebsitePage :one
INSERT INTO website_page (
    customer_id, website_id, url, sha_256, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT ON CONSTRAINT cnst_unique_website_page
DO UPDATE SET
    updated_at = CURRENT_TIMESTAMP,
    is_valid = TRUE
RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, vector_sha_256, created_at, updated_at
`

type CreateWebsitePageParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	WebsiteID  uuid.UUID `db:"website_id" json:"websiteId"`
	Url        string    `db:"url" json:"url"`
	Sha256     string    `db:"sha_256" json:"sha256"`
	Metadata   []byte    `db:"metadata" json:"metadata"`
}

// CreateWebsitePage
//
//	INSERT INTO website_page (
//	    customer_id, website_id, url, sha_256, metadata
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	ON CONFLICT ON CONSTRAINT cnst_unique_website_page
//	DO UPDATE SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    is_valid = TRUE
//	RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, vector_sha_256, created_at, updated_at
func (q *Queries) CreateWebsitePage(ctx context.Context, arg *CreateWebsitePageParams) (*WebsitePage, error) {
	row := q.db.QueryRow(ctx, createWebsitePage,
		arg.CustomerID,
		arg.WebsiteID,
		arg.Url,
		arg.Sha256,
		arg.Metadata,
	)
	var i WebsitePage
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WebsiteID,
		&i.Url,
		&i.Sha256,
		&i.IsValid,
		&i.Metadata,
		&i.Summary,
		&i.SummarySha256,
		&i.VectorSha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createWebsitePageVector = `-- name: CreateWebsitePageVector :one
INSERT INTO website_page_vector (
    website_page_id, vector_store_id, customer_id, index, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, website_page_id, vector_store_id, customer_id, index, metadata, created_at
`

type CreateWebsitePageVectorParams struct {
	WebsitePageID uuid.UUID `db:"website_page_id" json:"websitePageId"`
	VectorStoreID uuid.UUID `db:"vector_store_id" json:"vectorStoreId"`
	CustomerID    uuid.UUID `db:"customer_id" json:"customerId"`
	Index         int32     `db:"index" json:"index"`
	Metadata      []byte    `db:"metadata" json:"metadata"`
}

// CreateWebsitePageVector
//
//	INSERT INTO website_page_vector (
//	    website_page_id, vector_store_id, customer_id, index, metadata
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	RETURNING id, website_page_id, vector_store_id, customer_id, index, metadata, created_at
func (q *Queries) CreateWebsitePageVector(ctx context.Context, arg *CreateWebsitePageVectorParams) (*WebsitePageVector, error) {
	row := q.db.QueryRow(ctx, createWebsitePageVector,
		arg.WebsitePageID,
		arg.VectorStoreID,
		arg.CustomerID,
		arg.Index,
		arg.Metadata,
	)
	var i WebsitePageVector
	err := row.Scan(
		&i.ID,
		&i.WebsitePageID,
		&i.VectorStoreID,
		&i.CustomerID,
		&i.Index,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customer
WHERE id = $1
`

// DeleteCustomer
//
//	DELETE FROM customer
//	WHERE id = $1
func (q *Queries) DeleteCustomer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const deleteDocumentVectors = `-- name: DeleteDocumentVectors :exec
DELETE FROM document_vector
WHERE document_id = $1
`

// DeleteDocumentVectors
//
//	DELETE FROM document_vector
//	WHERE document_id = $1
func (q *Queries) DeleteDocumentVectors(ctx context.Context, documentID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDocumentVectors, documentID)
	return err
}

const deleteDocumentsOlderThan = `-- name: DeleteDocumentsOlderThan :exec
DELETE FROM document
WHERE customer_id = $1
AND updated_at < $2
`

type DeleteDocumentsOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// DeleteDocumentsOlderThan
//
//	DELETE FROM document
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) DeleteDocumentsOlderThan(ctx context.Context, arg *DeleteDocumentsOlderThanParams) error {
	_, err := q.db.Exec(ctx, deleteDocumentsOlderThan, arg.CustomerID, arg.UpdatedAt)
	return err
}

const deleteFoldersOlderThan = `-- name: DeleteFoldersOlderThan :exec
DELETE FROM folder
WHERE customer_id = $1
AND updated_at < $2
`

type DeleteFoldersOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// DeleteFoldersOlderThan
//
//	DELETE FROM folder
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) DeleteFoldersOlderThan(ctx context.Context, arg *DeleteFoldersOlderThanParams) error {
	_, err := q.db.Exec(ctx, deleteFoldersOlderThan, arg.CustomerID, arg.UpdatedAt)
	return err
}

const deleteWebsiteEmpty = `-- name: DeleteWebsiteEmpty :exec
DELETE FROM website w
WHERE w.customer_id = $1
AND NOT EXISTS (
    SELECT 1
    FROM website_page wp
    WHERE wp.website_id = w.id
)
`

// DeleteWebsiteEmpty
//
//	DELETE FROM website w
//	WHERE w.customer_id = $1
//	AND NOT EXISTS (
//	    SELECT 1
//	    FROM website_page wp
//	    WHERE wp.website_id = w.id
//	)
func (q *Queries) DeleteWebsiteEmpty(ctx context.Context, customerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebsiteEmpty, customerID)
	return err
}

const deleteWebsitePageVectors = `-- name: DeleteWebsitePageVectors :exec
DELETE FROM website_page_vector
WHERE website_page_id = $1
`

// DeleteWebsitePageVectors
//
//	DELETE FROM website_page_vector
//	WHERE website_page_id = $1
func (q *Queries) DeleteWebsitePageVectors(ctx context.Context, websitePageID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebsitePageVectors, websitePageID)
	return err
}

const deleteWebsitePagesNotValid = `-- name: DeleteWebsitePagesNotValid :exec
DELETE FROM website_page
WHERE customer_id = $1
AND website_id = $2
AND is_valid = FALSE
`

type DeleteWebsitePagesNotValidParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	WebsiteID  uuid.UUID `db:"website_id" json:"websiteId"`
}

// DeleteWebsitePagesNotValid
//
//	DELETE FROM website_page
//	WHERE customer_id = $1
//	AND website_id = $2
//	AND is_valid = FALSE
func (q *Queries) DeleteWebsitePagesNotValid(ctx context.Context, arg *DeleteWebsitePagesNotValidParams) error {
	_, err := q.db.Exec(ctx, deleteWebsitePagesNotValid, arg.CustomerID, arg.WebsiteID)
	return err
}

const deleteWebsitePagesOlderThan = `-- name: DeleteWebsitePagesOlderThan :exec
DELETE FROM website_page
WHERE customer_id = $1
AND updated_at < $2
`

type DeleteWebsitePagesOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// DeleteWebsitePagesOlderThan
//
//	DELETE FROM website_page
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) DeleteWebsitePagesOlderThan(ctx context.Context, arg *DeleteWebsitePagesOlderThanParams) error {
	_, err := q.db.Exec(ctx, deleteWebsitePagesOlderThan, arg.CustomerID, arg.UpdatedAt)
	return err
}

const getAvailableModel = `-- name: GetAvailableModel :one
SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
WHERE id = $1
`

// GetAvailableModel
//
//	SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
//	WHERE id = $1
func (q *Queries) GetAvailableModel(ctx context.Context, id string) (*AvailableModel, error) {
	row := q.db.QueryRow(ctx, getAvailableModel, id)
	var i AvailableModel
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.DisplayName,
		&i.Description,
		&i.InputTokenLimit,
		&i.OutputTokenLimit,
		&i.Currency,
		&i.InputCostPerMillionTokens,
		&i.OutputCostPerMillionTokens,
		&i.DepreciatedWarning,
		&i.IsDepreciated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAvailableModels = `-- name: GetAvailableModels :many
SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
`

// GetAvailableModels
//
//	SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
func (q *Queries) GetAvailableModels(ctx context.Context) ([]*AvailableModel, error) {
	rows, err := q.db.Query(ctx, getAvailableModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AvailableModel{}
	for rows.Next() {
		var i AvailableModel
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.DisplayName,
			&i.Description,
			&i.InputTokenLimit,
			&i.OutputTokenLimit,
			&i.Currency,
			&i.InputCostPerMillionTokens,
			&i.OutputCostPerMillionTokens,
			&i.DepreciatedWarning,
			&i.IsDepreciated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableModelsScoped = `-- name: GetAvailableModelsScoped :many
SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
WHERE provider = $1
`

// GetAvailableModelsScoped
//
//	SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
//	WHERE provider = $1
func (q *Queries) GetAvailableModelsScoped(ctx context.Context, provider string) ([]*AvailableModel, error) {
	rows, err := q.db.Query(ctx, getAvailableModelsScoped, provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AvailableModel{}
	for rows.Next() {
		var i AvailableModel
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.DisplayName,
			&i.Description,
			&i.InputTokenLimit,
			&i.OutputTokenLimit,
			&i.Currency,
			&i.InputCostPerMillionTokens,
			&i.OutputCostPerMillionTokens,
			&i.DepreciatedWarning,
			&i.IsDepreciated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBetaApiKey = `-- name: GetBetaApiKey :one
SELECT id, name, expired, created_at, updated_at FROM beta_api_key
WHERE id = $1
`

// GetBetaApiKey
//
//	SELECT id, name, expired, created_at, updated_at FROM beta_api_key
//	WHERE id = $1
func (q *Queries) GetBetaApiKey(ctx context.Context, id uuid.UUID) (*BetaApiKey, error) {
	row := q.db.QueryRow(ctx, getBetaApiKey, id)
	var i BetaApiKey
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Expired,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getConversation = `-- name: GetConversation :one
SELECT id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at FROM conversation
WHERE id = $1
`

// GetConversation
//
//	SELECT id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at FROM conversation
//	WHERE id = $1
func (q *Queries) GetConversation(ctx context.Context, id uuid.UUID) (*Conversation, error) {
	row := q.db.QueryRow(ctx, getConversation, id)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.ConversationType,
		&i.SystemMessage,
		&i.Metadata,
		&i.HasError,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT id, conversation_id, llm_id, model, temperature, instructions, role, message, index, tool_use_id, tool_name, tool_arguments, tool_results, created_at, updated_at FROM conversation_message
WHERE conversation_id = $1
ORDER BY index ASC
`

// GetConversationMessages
//
//	SELECT id, conversation_id, llm_id, model, temperature, instructions, role, message, index, tool_use_id, tool_name, tool_arguments, tool_results, created_at, updated_at FROM conversation_message
//	WHERE conversation_id = $1
//	ORDER BY index ASC
func (q *Queries) GetConversationMessages(ctx context.Context, conversationID uuid.UUID) ([]*ConversationMessage, error) {
	rows, err := q.db.Query(ctx, getConversationMessages, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ConversationMessage{}
	for rows.Next() {
		var i ConversationMessage
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.LlmID,
			&i.Model,
			&i.Temperature,
			&i.Instructions,
			&i.Role,
			&i.Message,
			&i.Index,
			&i.ToolUseID,
			&i.ToolName,
			&i.ToolArguments,
			&i.ToolResults,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversations = `-- name: GetConversations :many
SELECT id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at FROM conversation
WHERE customer_id = $1
ORDER BY updated_at DESC
`

// GetConversations
//
//	SELECT id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at FROM conversation
//	WHERE customer_id = $1
//	ORDER BY updated_at DESC
func (q *Queries) GetConversations(ctx context.Context, customerID uuid.UUID) ([]*Conversation, error) {
	rows, err := q.db.Query(ctx, getConversations, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Title,
			&i.ConversationType,
			&i.SystemMessage,
			&i.Metadata,
			&i.HasError,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsWithCount = `-- name: GetConversationsWithCount :many
SELECT c.id, c.customer_id, c.title, c.conversation_type, c.system_message, c.metadata, c.has_error, c.error_message, c.created_at, c.updated_at, COUNT(cm.id) AS message_count
FROM conversation c
JOIN conversation_message cm
ON c.id = cm.conversation_id
WHERE c.customer_id = $1
GROUP BY c.id
ORDER BY c.updated_at DESC
`

type GetConversationsWithCountRow struct {
	ID               uuid.UUID          `db:"id" json:"id"`
	CustomerID       uuid.UUID          `db:"customer_id" json:"customerId"`
	Title            string             `db:"title" json:"title"`
	ConversationType string             `db:"conversation_type" json:"conversationType"`
	SystemMessage    string             `db:"system_message" json:"systemMessage"`
	Metadata         []byte             `db:"metadata" json:"metadata"`
	HasError         bool               `db:"has_error" json:"hasError"`
	ErrorMessage     *string            `db:"error_message" json:"errorMessage"`
	CreatedAt        pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt        pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	MessageCount     int64              `db:"message_count" json:"messageCount"`
}

// GetConversationsWithCount
//
//	SELECT c.id, c.customer_id, c.title, c.conversation_type, c.system_message, c.metadata, c.has_error, c.error_message, c.created_at, c.updated_at, COUNT(cm.id) AS message_count
//	FROM conversation c
//	JOIN conversation_message cm
//	ON c.id = cm.conversation_id
//	WHERE c.customer_id = $1
//	GROUP BY c.id
//	ORDER BY c.updated_at DESC
func (q *Queries) GetConversationsWithCount(ctx context.Context, customerID uuid.UUID) ([]*GetConversationsWithCountRow, error) {
	rows, err := q.db.Query(ctx, getConversationsWithCount, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetConversationsWithCountRow{}
	for rows.Next() {
		var i GetConversationsWithCountRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Title,
			&i.ConversationType,
			&i.SystemMessage,
			&i.Metadata,
			&i.HasError,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, name, datastore, created_at, updated_at FROM customer
WHERE id = $1 LIMIT 1
`

// GetCustomer
//
//	SELECT id, name, datastore, created_at, updated_at FROM customer
//	WHERE id = $1 LIMIT 1
func (q *Queries) GetCustomer(ctx context.Context, id uuid.UUID) (*Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Datastore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getCustomerByName = `-- name: GetCustomerByName :one
SELECT id, name, datastore, created_at, updated_at FROM customer
WHERE name = $1 LIMIT 1
`

// GetCustomerByName
//
//	SELECT id, name, datastore, created_at, updated_at FROM customer
//	WHERE name = $1 LIMIT 1
func (q *Queries) GetCustomerByName(ctx context.Context, name string) (*Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByName, name)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Datastore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getCustomerChatLLM = `-- name: GetCustomerChatLLM :one
WITH RequiredLLM AS (
    -- First, try to find a customer-specific llm from the configurations
    SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at FROM customer_llm_configurations clc
    JOIN llm ON llm.id = clc.chat_llm_id
    WHERE clc.customer_id = $1

    UNION ALL

    -- Fallback to a global default if no customer-specific default is found
    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
    WHERE llm.customer_id IS NULL AND llm.is_default = true
    AND NOT EXISTS (
        SELECT 1
        FROM customer_llm_configurations clc
        JOIN llm ON llm.id = clc.chat_llm_id
        WHERE clc.customer_id = $1
    )
)
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
FROM RequiredLLM llm
INNER JOIN available_model am ON am.id = llm.model
LIMIT 1
`

type GetCustomerChatLLMRow struct {
	Llm            Llm            `db:"llm" json:"llm"`
	AvailableModel AvailableModel `db:"available_model" json:"availableModel"`
}

// GetCustomerChatLLM
//
//	WITH RequiredLLM AS (
//	    -- First, try to find a customer-specific llm from the configurations
//	    SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at FROM customer_llm_configurations clc
//	    JOIN llm ON llm.id = clc.chat_llm_id
//	    WHERE clc.customer_id = $1
//
//	    UNION ALL
//
//	    -- Fallback to a global default if no customer-specific default is found
//	    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
//	    WHERE llm.customer_id IS NULL AND llm.is_default = true
//	    AND NOT EXISTS (
//	        SELECT 1
//	        FROM customer_llm_configurations clc
//	        JOIN llm ON llm.id = clc.chat_llm_id
//	        WHERE clc.customer_id = $1
//	    )
//	)
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
//	FROM RequiredLLM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	LIMIT 1
func (q *Queries) GetCustomerChatLLM(ctx context.Context, customerID uuid.UUID) (*GetCustomerChatLLMRow, error) {
	row := q.db.QueryRow(ctx, getCustomerChatLLM, customerID)
	var i GetCustomerChatLLMRow
	err := row.Scan(
		&i.Llm.ID,
		&i.Llm.CustomerID,
		&i.Llm.Title,
		&i.Llm.Color,
		&i.Llm.Model,
		&i.Llm.Temperature,
		&i.Llm.Instructions,
		&i.Llm.IsDefault,
		&i.Llm.Public,
		&i.Llm.CreatedAt,
		&i.Llm.UpdatedAt,
		&i.AvailableModel.ID,
		&i.AvailableModel.Provider,
		&i.AvailableModel.DisplayName,
		&i.AvailableModel.Description,
		&i.AvailableModel.InputTokenLimit,
		&i.AvailableModel.OutputTokenLimit,
		&i.AvailableModel.Currency,
		&i.AvailableModel.InputCostPerMillionTokens,
		&i.AvailableModel.OutputCostPerMillionTokens,
		&i.AvailableModel.DepreciatedWarning,
		&i.AvailableModel.IsDepreciated,
		&i.AvailableModel.CreatedAt,
		&i.AvailableModel.UpdatedAt,
	)
	return &i, err
}

const getCustomerLLMConfigurations = `-- name: GetCustomerLLMConfigurations :one
SELECT customer_id, summary_llm_id, chat_llm_id, created_at, updated_at FROM customer_llm_configurations
WHERE customer_id = $1
`

// GetCustomerLLMConfigurations
//
//	SELECT customer_id, summary_llm_id, chat_llm_id, created_at, updated_at FROM customer_llm_configurations
//	WHERE customer_id = $1
func (q *Queries) GetCustomerLLMConfigurations(ctx context.Context, customerID uuid.UUID) (*CustomerLlmConfiguration, error) {
	row := q.db.QueryRow(ctx, getCustomerLLMConfigurations, customerID)
	var i CustomerLlmConfiguration
	err := row.Scan(
		&i.CustomerID,
		&i.SummaryLlmID,
		&i.ChatLlmID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getCustomerSummaryLLM = `-- name: GetCustomerSummaryLLM :one
WITH RequiredLLM AS (
    -- First, try to find a customer-specific llm from the configurations
    SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at FROM customer_llm_configurations clc
    JOIN llm ON llm.id = clc.summary_llm_id
    WHERE clc.customer_id = $1

    UNION ALL

    -- Fallback to a global default if no customer-specific default is found
    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
    WHERE llm.customer_id IS NULL AND llm.is_default = true
    AND NOT EXISTS (
        SELECT 1
        FROM customer_llm_configurations clc
        JOIN llm ON llm.id = clc.summary_llm_id
        WHERE clc.customer_id = $1
    )
)
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
FROM RequiredLLM llm
INNER JOIN available_model am ON am.id = llm.model
LIMIT 1
`

type GetCustomerSummaryLLMRow struct {
	Llm            Llm            `db:"llm" json:"llm"`
	AvailableModel AvailableModel `db:"available_model" json:"availableModel"`
}

// GetCustomerSummaryLLM
//
//	WITH RequiredLLM AS (
//	    -- First, try to find a customer-specific llm from the configurations
//	    SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at FROM customer_llm_configurations clc
//	    JOIN llm ON llm.id = clc.summary_llm_id
//	    WHERE clc.customer_id = $1
//
//	    UNION ALL
//
//	    -- Fallback to a global default if no customer-specific default is found
//	    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
//	    WHERE llm.customer_id IS NULL AND llm.is_default = true
//	    AND NOT EXISTS (
//	        SELECT 1
//	        FROM customer_llm_configurations clc
//	        JOIN llm ON llm.id = clc.summary_llm_id
//	        WHERE clc.customer_id = $1
//	    )
//	)
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
//	FROM RequiredLLM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	LIMIT 1
func (q *Queries) GetCustomerSummaryLLM(ctx context.Context, customerID uuid.UUID) (*GetCustomerSummaryLLMRow, error) {
	row := q.db.QueryRow(ctx, getCustomerSummaryLLM, customerID)
	var i GetCustomerSummaryLLMRow
	err := row.Scan(
		&i.Llm.ID,
		&i.Llm.CustomerID,
		&i.Llm.Title,
		&i.Llm.Color,
		&i.Llm.Model,
		&i.Llm.Temperature,
		&i.Llm.Instructions,
		&i.Llm.IsDefault,
		&i.Llm.Public,
		&i.Llm.CreatedAt,
		&i.Llm.UpdatedAt,
		&i.AvailableModel.ID,
		&i.AvailableModel.Provider,
		&i.AvailableModel.DisplayName,
		&i.AvailableModel.Description,
		&i.AvailableModel.InputTokenLimit,
		&i.AvailableModel.OutputTokenLimit,
		&i.AvailableModel.Currency,
		&i.AvailableModel.InputCostPerMillionTokens,
		&i.AvailableModel.OutputCostPerMillionTokens,
		&i.AvailableModel.DepreciatedWarning,
		&i.AvailableModel.IsDepreciated,
		&i.AvailableModel.CreatedAt,
		&i.AvailableModel.UpdatedAt,
	)
	return &i, err
}

const getCustomerVectorizeJobs = `-- name: GetCustomerVectorizeJobs :many
WITH latest_vji AS (
    SELECT 
        vji.id, vji.job_id, vji.status, vji.message, vji.error, vji.created_at, vji.updated_at, 
        ROW_NUMBER() OVER (PARTITION BY vji.job_id ORDER BY vji.created_at DESC) AS rn
    FROM 
        vectorize_job_item vji
)
SELECT 
    vj.id, vj.customer_id, vj.documents, vj.websites, vj.created_at, vj.updated_at, 
    vji.status, 
    vji.message, 
    vji.error
FROM 
    vectorize_job vj
LEFT JOIN 
    latest_vji vji 
    ON vj.id = vji.job_id 
    AND vji.rn = 1
WHERE 
    vj.customer_id = $1
ORDER BY 
    vj.created_at DESC
`

type GetCustomerVectorizeJobsRow struct {
	ID         uuid.UUID              `db:"id" json:"id"`
	CustomerID uuid.UUID              `db:"customer_id" json:"customerId"`
	Documents  bool                   `db:"documents" json:"documents"`
	Websites   bool                   `db:"websites" json:"websites"`
	CreatedAt  pgtype.Timestamptz     `db:"created_at" json:"createdAt"`
	UpdatedAt  pgtype.Timestamptz     `db:"updated_at" json:"updatedAt"`
	Status     NullVectorizeJobStatus `db:"status" json:"status"`
	Message    *string                `db:"message" json:"message"`
	Error      *string                `db:"error" json:"error"`
}

// GetCustomerVectorizeJobs
//
//	WITH latest_vji AS (
//	    SELECT
//	        vji.id, vji.job_id, vji.status, vji.message, vji.error, vji.created_at, vji.updated_at,
//	        ROW_NUMBER() OVER (PARTITION BY vji.job_id ORDER BY vji.created_at DESC) AS rn
//	    FROM
//	        vectorize_job_item vji
//	)
//	SELECT
//	    vj.id, vj.customer_id, vj.documents, vj.websites, vj.created_at, vj.updated_at,
//	    vji.status,
//	    vji.message,
//	    vji.error
//	FROM
//	    vectorize_job vj
//	LEFT JOIN
//	    latest_vji vji
//	    ON vj.id = vji.job_id
//	    AND vji.rn = 1
//	WHERE
//	    vj.customer_id = $1
//	ORDER BY
//	    vj.created_at DESC
func (q *Queries) GetCustomerVectorizeJobs(ctx context.Context, customerID uuid.UUID) ([]*GetCustomerVectorizeJobsRow, error) {
	rows, err := q.db.Query(ctx, getCustomerVectorizeJobs, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetCustomerVectorizeJobsRow{}
	for rows.Next() {
		var i GetCustomerVectorizeJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Documents,
			&i.Websites,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Message,
			&i.Error,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultLLM = `-- name: GetDefaultLLM :one
WITH RequiredLLM AS (
    -- First, try to find a customer-specific default if customer_id is provided
    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
    WHERE llm.customer_id = $1 AND llm.is_default = true

    UNION ALL

    -- Fallback to a global default if no customer-specific default is found
    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
    WHERE llm.customer_id IS NULL AND llm.is_default = true
    AND NOT EXISTS (
        SELECT 1
        FROM llm
        WHERE llm.customer_id = $1 AND llm.is_default = true
    )
)
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
FROM RequiredLLM llm
INNER JOIN available_model am ON am.id = llm.model
LIMIT 1
`

type GetDefaultLLMRow struct {
	Llm            Llm            `db:"llm" json:"llm"`
	AvailableModel AvailableModel `db:"available_model" json:"availableModel"`
}

// GetDefaultLLM
//
//	WITH RequiredLLM AS (
//	    -- First, try to find a customer-specific default if customer_id is provided
//	    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
//	    WHERE llm.customer_id = $1 AND llm.is_default = true
//
//	    UNION ALL
//
//	    -- Fallback to a global default if no customer-specific default is found
//	    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
//	    WHERE llm.customer_id IS NULL AND llm.is_default = true
//	    AND NOT EXISTS (
//	        SELECT 1
//	        FROM llm
//	        WHERE llm.customer_id = $1 AND llm.is_default = true
//	    )
//	)
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
//	FROM RequiredLLM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	LIMIT 1
func (q *Queries) GetDefaultLLM(ctx context.Context, customerID pgtype.UUID) (*GetDefaultLLMRow, error) {
	row := q.db.QueryRow(ctx, getDefaultLLM, customerID)
	var i GetDefaultLLMRow
	err := row.Scan(
		&i.Llm.ID,
		&i.Llm.CustomerID,
		&i.Llm.Title,
		&i.Llm.Color,
		&i.Llm.Model,
		&i.Llm.Temperature,
		&i.Llm.Instructions,
		&i.Llm.IsDefault,
		&i.Llm.Public,
		&i.Llm.CreatedAt,
		&i.Llm.UpdatedAt,
		&i.AvailableModel.ID,
		&i.AvailableModel.Provider,
		&i.AvailableModel.DisplayName,
		&i.AvailableModel.Description,
		&i.AvailableModel.InputTokenLimit,
		&i.AvailableModel.OutputTokenLimit,
		&i.AvailableModel.Currency,
		&i.AvailableModel.InputCostPerMillionTokens,
		&i.AvailableModel.OutputCostPerMillionTokens,
		&i.AvailableModel.DepreciatedWarning,
		&i.AvailableModel.IsDepreciated,
		&i.AvailableModel.CreatedAt,
		&i.AvailableModel.UpdatedAt,
	)
	return &i, err
}

const getDocument = `-- name: GetDocument :one
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
WHERE id = $1 LIMIT 1
`

// GetDocument
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
//	WHERE id = $1 LIMIT 1
func (q *Queries) GetDocument(ctx context.Context, id uuid.UUID) (*Document, error) {
	row := q.db.QueryRow(ctx, getDocument, id)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Filename,
		&i.Type,
		&i.SizeBytes,
		&i.Sha256,
		&i.Validated,
		&i.DatastoreType,
		&i.DatastoreID,
		&i.Summary,
		&i.SummarySha256,
		&i.VectorSha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getDocumentsByCustomer = `-- name: GetDocumentsByCustomer :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
WHERE customer_id = $1 AND validated = true
`

// GetDocumentsByCustomer
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
//	WHERE customer_id = $1 AND validated = true
func (q *Queries) GetDocumentsByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getDocumentsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.VectorSha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentsFromListIDs = `-- name: GetDocumentsFromListIDs :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at from document
WHERE customer_id = $1
AND id = ANY($2::uuid[])
AND ($3::uuid[] IS NULL OR parent_id = ANY($3::uuid[]))
`

type GetDocumentsFromListIDsParams struct {
	CustomerID uuid.UUID   `db:"customer_id" json:"customerId"`
	Column2    []uuid.UUID `db:"column_2" json:"column2"`
	Column3    []uuid.UUID `db:"column_3" json:"column3"`
}

// GetDocumentsFromListIDs
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at from document
//	WHERE customer_id = $1
//	AND id = ANY($2::uuid[])
//	AND ($3::uuid[] IS NULL OR parent_id = ANY($3::uuid[]))
func (q *Queries) GetDocumentsFromListIDs(ctx context.Context, arg *GetDocumentsFromListIDsParams) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getDocumentsFromListIDs, arg.CustomerID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.VectorSha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentsFromParent = `-- name: GetDocumentsFromParent :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
WHERE parent_id = $1 AND validated = true
`

// GetDocumentsFromParent
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
//	WHERE parent_id = $1 AND validated = true
func (q *Queries) GetDocumentsFromParent(ctx context.Context, parentID pgtype.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getDocumentsFromParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.VectorSha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentsOlderThan = `-- name: GetDocumentsOlderThan :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
WHERE customer_id = $1
AND updated_at < $2
`

type GetDocumentsOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// GetDocumentsOlderThan
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) GetDocumentsOlderThan(ctx context.Context, arg *GetDocumentsOlderThanParams) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getDocumentsOlderThan, arg.CustomerID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.VectorSha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFolder = `-- name: GetFolder :one
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE id = $1 LIMIT 1
`

// GetFolder
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE id = $1 LIMIT 1
func (q *Queries) GetFolder(ctx context.Context, id uuid.UUID) (*Folder, error) {
	row := q.db.QueryRow(ctx, getFolder, id)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getFolderWithName = `-- name: GetFolderWithName :one
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE customer_id = $1 AND title = $2
LIMIT 1
`

type GetFolderWithNameParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	Title      string    `db:"title" json:"title"`
}

// GetFolderWithName
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE customer_id = $1 AND title = $2
//	LIMIT 1
func (q *Queries) GetFolderWithName(ctx context.Context, arg *GetFolderWithNameParams) (*Folder, error) {
	row := q.db.QueryRow(ctx, getFolderWithName, arg.CustomerID, arg.Title)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getFoldersByCustomer = `-- name: GetFoldersByCustomer :many
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE customer_id = $1
`

// GetFoldersByCustomer
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE customer_id = $1
func (q *Queries) GetFoldersByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Folder, error) {
	rows, err := q.db.Query(ctx, getFoldersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFoldersFromParent = `-- name: GetFoldersFromParent :many
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE parent_id = $1
`

// GetFoldersFromParent
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE parent_id = $1
func (q *Queries) GetFoldersFromParent(ctx context.Context, parentID pgtype.UUID) ([]*Folder, error) {
	rows, err := q.db.Query(ctx, getFoldersFromParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFoldersOlderThan = `-- name: GetFoldersOlderThan :many
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE customer_id = $1
AND updated_at < $2
`

type GetFoldersOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// GetFoldersOlderThan
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) GetFoldersOlderThan(ctx context.Context, arg *GetFoldersOlderThanParams) ([]*Folder, error) {
	rows, err := q.db.Query(ctx, getFoldersOlderThan, arg.CustomerID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInteralLLM = `-- name: GetInteralLLM :one
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
INNER JOIN available_model am ON am.id = llm.model
WHERE title = $1 AND public = false
LIMIT 1
`

type GetInteralLLMRow struct {
	Llm            Llm            `db:"llm" json:"llm"`
	AvailableModel AvailableModel `db:"available_model" json:"availableModel"`
}

// GetInteralLLM
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	WHERE title = $1 AND public = false
//	LIMIT 1
func (q *Queries) GetInteralLLM(ctx context.Context, title string) (*GetInteralLLMRow, error) {
	row := q.db.QueryRow(ctx, getInteralLLM, title)
	var i GetInteralLLMRow
	err := row.Scan(
		&i.Llm.ID,
		&i.Llm.CustomerID,
		&i.Llm.Title,
		&i.Llm.Color,
		&i.Llm.Model,
		&i.Llm.Temperature,
		&i.Llm.Instructions,
		&i.Llm.IsDefault,
		&i.Llm.Public,
		&i.Llm.CreatedAt,
		&i.Llm.UpdatedAt,
		&i.AvailableModel.ID,
		&i.AvailableModel.Provider,
		&i.AvailableModel.DisplayName,
		&i.AvailableModel.Description,
		&i.AvailableModel.InputTokenLimit,
		&i.AvailableModel.OutputTokenLimit,
		&i.AvailableModel.Currency,
		&i.AvailableModel.InputCostPerMillionTokens,
		&i.AvailableModel.OutputCostPerMillionTokens,
		&i.AvailableModel.DepreciatedWarning,
		&i.AvailableModel.IsDepreciated,
		&i.AvailableModel.CreatedAt,
		&i.AvailableModel.UpdatedAt,
	)
	return &i, err
}

const getLLM = `-- name: GetLLM :one
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
INNER JOIN available_model am ON am.id = llm.model
WHERE llm.id = $1
`

type GetLLMRow struct {
	Llm            Llm            `db:"llm" json:"llm"`
	AvailableModel AvailableModel `db:"available_model" json:"availableModel"`
}

// GetLLM
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	WHERE llm.id = $1
func (q *Queries) GetLLM(ctx context.Context, id uuid.UUID) (*GetLLMRow, error) {
	row := q.db.QueryRow(ctx, getLLM, id)
	var i GetLLMRow
	err := row.Scan(
		&i.Llm.ID,
		&i.Llm.CustomerID,
		&i.Llm.Title,
		&i.Llm.Color,
		&i.Llm.Model,
		&i.Llm.Temperature,
		&i.Llm.Instructions,
		&i.Llm.IsDefault,
		&i.Llm.Public,
		&i.Llm.CreatedAt,
		&i.Llm.UpdatedAt,
		&i.AvailableModel.ID,
		&i.AvailableModel.Provider,
		&i.AvailableModel.DisplayName,
		&i.AvailableModel.Description,
		&i.AvailableModel.InputTokenLimit,
		&i.AvailableModel.OutputTokenLimit,
		&i.AvailableModel.Currency,
		&i.AvailableModel.InputCostPerMillionTokens,
		&i.AvailableModel.OutputCostPerMillionTokens,
		&i.AvailableModel.DepreciatedWarning,
		&i.AvailableModel.IsDepreciated,
		&i.AvailableModel.CreatedAt,
		&i.AvailableModel.UpdatedAt,
	)
	return &i, err
}

const getLLMsByCustomer = `-- name: GetLLMsByCustomer :many
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
FROM llm
INNER JOIN available_model am ON am.id = llm.model
WHERE llm.customer_id = $1
`

type GetLLMsByCustomerRow struct {
	Llm            Llm            `db:"llm" json:"llm"`
	AvailableModel AvailableModel `db:"available_model" json:"availableModel"`
}

// GetLLMsByCustomer
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
//	FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	WHERE llm.customer_id = $1
func (q *Queries) GetLLMsByCustomer(ctx context.Context, customerID pgtype.UUID) ([]*GetLLMsByCustomerRow, error) {
	rows, err := q.db.Query(ctx, getLLMsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLLMsByCustomerRow{}
	for rows.Next() {
		var i GetLLMsByCustomerRow
		if err := rows.Scan(
			&i.Llm.ID,
			&i.Llm.CustomerID,
			&i.Llm.Title,
			&i.Llm.Color,
			&i.Llm.Model,
			&i.Llm.Temperature,
			&i.Llm.Instructions,
			&i.Llm.IsDefault,
			&i.Llm.Public,
			&i.Llm.CreatedAt,
			&i.Llm.UpdatedAt,
			&i.AvailableModel.ID,
			&i.AvailableModel.Provider,
			&i.AvailableModel.DisplayName,
			&i.AvailableModel.Description,
			&i.AvailableModel.InputTokenLimit,
			&i.AvailableModel.OutputTokenLimit,
			&i.AvailableModel.Currency,
			&i.AvailableModel.InputCostPerMillionTokens,
			&i.AvailableModel.OutputCostPerMillionTokens,
			&i.AvailableModel.DepreciatedWarning,
			&i.AvailableModel.IsDepreciated,
			&i.AvailableModel.CreatedAt,
			&i.AvailableModel.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByCustomerAvailable = `-- name: GetLLMsByCustomerAvailable :many
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
FROM llm
INNER JOIN available_model am ON am.id = llm.model
WHERE (llm.customer_id IS NULL OR llm.customer_id = $1)
AND llm.public = true
`

type GetLLMsByCustomerAvailableRow struct {
	Llm            Llm            `db:"llm" json:"llm"`
	AvailableModel AvailableModel `db:"available_model" json:"availableModel"`
}

// GetLLMsByCustomerAvailable
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
//	FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	WHERE (llm.customer_id IS NULL OR llm.customer_id = $1)
//	AND llm.public = true
func (q *Queries) GetLLMsByCustomerAvailable(ctx context.Context, customerID pgtype.UUID) ([]*GetLLMsByCustomerAvailableRow, error) {
	rows, err := q.db.Query(ctx, getLLMsByCustomerAvailable, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLLMsByCustomerAvailableRow{}
	for rows.Next() {
		var i GetLLMsByCustomerAvailableRow
		if err := rows.Scan(
			&i.Llm.ID,
			&i.Llm.CustomerID,
			&i.Llm.Title,
			&i.Llm.Color,
			&i.Llm.Model,
			&i.Llm.Temperature,
			&i.Llm.Instructions,
			&i.Llm.IsDefault,
			&i.Llm.Public,
			&i.Llm.CreatedAt,
			&i.Llm.UpdatedAt,
			&i.AvailableModel.ID,
			&i.AvailableModel.Provider,
			&i.AvailableModel.DisplayName,
			&i.AvailableModel.Description,
			&i.AvailableModel.InputTokenLimit,
			&i.AvailableModel.OutputTokenLimit,
			&i.AvailableModel.Currency,
			&i.AvailableModel.InputCostPerMillionTokens,
			&i.AvailableModel.OutputCostPerMillionTokens,
			&i.AvailableModel.DepreciatedWarning,
			&i.AvailableModel.IsDepreciated,
			&i.AvailableModel.CreatedAt,
			&i.AvailableModel.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkedInPost = `-- name: GetLinkedInPost :one
SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
WHERE id = $1
`

// GetLinkedInPost
//
//	SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
//	WHERE id = $1
func (q *Queries) GetLinkedInPost(ctx context.Context, id uuid.UUID) (*LinkedinPost, error) {
	row := q.db.QueryRow(ctx, getLinkedInPost, id)
	var i LinkedinPost
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectLibraryID,
		&i.ProjectIdeaID,
		&i.Title,
		&i.AssetID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getLinkedInPostConfig = `-- name: GetLinkedInPostConfig :one
WITH LinkedInPostConfig AS (
    -- First, try to find a post-specific config
    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
    WHERE linkedin_post_config.project_id = $1 AND linkedin_post_config.linkedin_post_id = $2

    UNION ALL

    -- Fallback to the project's default
    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
    WHERE linkedin_post_config.project_id = $1 AND linkedin_post_config.linkedin_post_id IS NULL

    UNION ALL
    
    -- Finally fallback to global config
    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
    WHERE linkedin_post_config.project_id IS NULL
)
SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM LinkedInPostConfig
LIMIT 1
`

type GetLinkedInPostConfigParams struct {
	ProjectID      pgtype.UUID `db:"project_id" json:"projectId"`
	LinkedinPostID pgtype.UUID `db:"linkedin_post_id" json:"linkedinPostId"`
}

type GetLinkedInPostConfigRow struct {
	ID                        uuid.UUID          `db:"id" json:"id"`
	ProjectID                 pgtype.UUID        `db:"project_id" json:"projectId"`
	LinkedinPostID            pgtype.UUID        `db:"linkedin_post_id" json:"linkedinPostId"`
	MinSections               int32              `db:"min_sections" json:"minSections"`
	MaxSections               int32              `db:"max_sections" json:"maxSections"`
	NumDocuments              int32              `db:"num_documents" json:"numDocuments"`
	NumWebsitePages           int32              `db:"num_website_pages" json:"numWebsitePages"`
	LlmContentGenerationID    pgtype.UUID        `db:"llm_content_generation_id" json:"llmContentGenerationId"`
	LlmVectorSummarizationID  pgtype.UUID        `db:"llm_vector_summarization_id" json:"llmVectorSummarizationId"`
	LlmWebsiteSummarizationID pgtype.UUID        `db:"llm_website_summarization_id" json:"llmWebsiteSummarizationId"`
	LlmProofReadingID         pgtype.UUID        `db:"llm_proof_reading_id" json:"llmProofReadingId"`
	CreatedAt                 pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt                 pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// GetLinkedInPostConfig
//
//	WITH LinkedInPostConfig AS (
//	    -- First, try to find a post-specific config
//	    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
//	    WHERE linkedin_post_config.project_id = $1 AND linkedin_post_config.linkedin_post_id = $2
//
//	    UNION ALL
//
//	    -- Fallback to the project's default
//	    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
//	    WHERE linkedin_post_config.project_id = $1 AND linkedin_post_config.linkedin_post_id IS NULL
//
//	    UNION ALL
//
//	    -- Finally fallback to global config
//	    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
//	    WHERE linkedin_post_config.project_id IS NULL
//	)
//	SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM LinkedInPostConfig
//	LIMIT 1
func (q *Queries) GetLinkedInPostConfig(ctx context.Context, arg *GetLinkedInPostConfigParams) (*GetLinkedInPostConfigRow, error) {
	row := q.db.QueryRow(ctx, getLinkedInPostConfig, arg.ProjectID, arg.LinkedinPostID)
	var i GetLinkedInPostConfigRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.LinkedinPostID,
		&i.MinSections,
		&i.MaxSections,
		&i.NumDocuments,
		&i.NumWebsitePages,
		&i.LlmContentGenerationID,
		&i.LlmVectorSummarizationID,
		&i.LlmWebsiteSummarizationID,
		&i.LlmProofReadingID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getLinkedInPostLibrary = `-- name: GetLinkedInPostLibrary :one
SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
WHERE project_library_id = $1
`

// GetLinkedInPostLibrary
//
//	SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
//	WHERE project_library_id = $1
func (q *Queries) GetLinkedInPostLibrary(ctx context.Context, projectLibraryID uuid.UUID) (*LinkedinPost, error) {
	row := q.db.QueryRow(ctx, getLinkedInPostLibrary, projectLibraryID)
	var i LinkedinPost
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectLibraryID,
		&i.ProjectIdeaID,
		&i.Title,
		&i.AssetID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getLinkedInPosts = `-- name: GetLinkedInPosts :many
SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
WHERE project_id = $1
`

// GetLinkedInPosts
//
//	SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
//	WHERE project_id = $1
func (q *Queries) GetLinkedInPosts(ctx context.Context, projectID uuid.UUID) ([]*LinkedinPost, error) {
	rows, err := q.db.Query(ctx, getLinkedInPosts, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LinkedinPost{}
	for rows.Next() {
		var i LinkedinPost
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectLibraryID,
			&i.ProjectIdeaID,
			&i.Title,
			&i.AssetID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProject = `-- name: GetProject :one
SELECT id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at FROM project
WHERE id = $1
`

// GetProject
//
//	SELECT id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at FROM project
//	WHERE id = $1
func (q *Queries) GetProject(ctx context.Context, id uuid.UUID) (*Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Topic,
		&i.IdeaGenerationModelID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProjectIdea = `-- name: GetProjectIdea :one
SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
WHERE id = $1
`

// GetProjectIdea
//
//	SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
//	WHERE id = $1
func (q *Queries) GetProjectIdea(ctx context.Context, id uuid.UUID) (*ProjectIdea, error) {
	row := q.db.QueryRow(ctx, getProjectIdea, id)
	var i ProjectIdea
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConversationID,
		&i.Title,
		&i.Used,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProjectIdeas = `-- name: GetProjectIdeas :many
SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
WHERE project_id = $1
`

// GetProjectIdeas
//
//	SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
//	WHERE project_id = $1
func (q *Queries) GetProjectIdeas(ctx context.Context, projectID uuid.UUID) ([]*ProjectIdea, error) {
	rows, err := q.db.Query(ctx, getProjectIdeas, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProjectIdea{}
	for rows.Next() {
		var i ProjectIdea
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConversationID,
			&i.Title,
			&i.Used,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectIdeasConversation = `-- name: GetProjectIdeasConversation :many
SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
WHERE conversation_id = $1
ORDER BY created_at DESC
`

// GetProjectIdeasConversation
//
//	SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
//	WHERE conversation_id = $1
//	ORDER BY created_at DESC
func (q *Queries) GetProjectIdeasConversation(ctx context.Context, conversationID pgtype.UUID) ([]*ProjectIdea, error) {
	rows, err := q.db.Query(ctx, getProjectIdeasConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProjectIdea{}
	for rows.Next() {
		var i ProjectIdea
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConversationID,
			&i.Title,
			&i.Used,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectLibrary = `-- name: GetProjectLibrary :many
SELECT id, project_id, title, content_type, draft, published, created_at, updated_at FROM project_library
WHERE project_id = $1
`

// GetProjectLibrary
//
//	SELECT id, project_id, title, content_type, draft, published, created_at, updated_at FROM project_library
//	WHERE project_id = $1
func (q *Queries) GetProjectLibrary(ctx context.Context, projectID uuid.UUID) ([]*ProjectLibrary, error) {
	rows, err := q.db.Query(ctx, getProjectLibrary, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProjectLibrary{}
	for rows.Next() {
		var i ProjectLibrary
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Title,
			&i.ContentType,
			&i.Draft,
			&i.Published,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjects = `-- name: GetProjects :many
SELECT id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at FROM project
WHERE customer_id = $1
`

// GetProjects
//
//	SELECT id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at FROM project
//	WHERE customer_id = $1
func (q *Queries) GetProjects(ctx context.Context, customerID uuid.UUID) ([]*Project, error) {
	rows, err := q.db.Query(ctx, getProjects, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Title,
			&i.Topic,
			&i.IdeaGenerationModelID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicLLMs = `-- name: GetPublicLLMs :many
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
INNER JOIN available_model am ON am.id = llm.model
where customer_id IS NULL AND public = true
`

type GetPublicLLMsRow struct {
	Llm            Llm            `db:"llm" json:"llm"`
	AvailableModel AvailableModel `db:"available_model" json:"availableModel"`
}

// GetPublicLLMs
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	where customer_id IS NULL AND public = true
func (q *Queries) GetPublicLLMs(ctx context.Context) ([]*GetPublicLLMsRow, error) {
	rows, err := q.db.Query(ctx, getPublicLLMs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPublicLLMsRow{}
	for rows.Next() {
		var i GetPublicLLMsRow
		if err := rows.Scan(
			&i.Llm.ID,
			&i.Llm.CustomerID,
			&i.Llm.Title,
			&i.Llm.Color,
			&i.Llm.Model,
			&i.Llm.Temperature,
			&i.Llm.Instructions,
			&i.Llm.IsDefault,
			&i.Llm.Public,
			&i.Llm.CreatedAt,
			&i.Llm.UpdatedAt,
			&i.AvailableModel.ID,
			&i.AvailableModel.Provider,
			&i.AvailableModel.DisplayName,
			&i.AvailableModel.Description,
			&i.AvailableModel.InputTokenLimit,
			&i.AvailableModel.OutputTokenLimit,
			&i.AvailableModel.Currency,
			&i.AvailableModel.InputCostPerMillionTokens,
			&i.AvailableModel.OutputCostPerMillionTokens,
			&i.AvailableModel.DepreciatedWarning,
			&i.AvailableModel.IsDepreciated,
			&i.AvailableModel.CreatedAt,
			&i.AvailableModel.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootDocumentsByCustomer = `-- name: GetRootDocumentsByCustomer :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
WHERE customer_id = $1 AND parent_id is NULL
`

// GetRootDocumentsByCustomer
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
//	WHERE customer_id = $1 AND parent_id is NULL
func (q *Queries) GetRootDocumentsByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getRootDocumentsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.VectorSha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootFoldersByCustomer = `-- name: GetRootFoldersByCustomer :many
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE customer_id = $1 AND parent_id IS NULL
`

// GetRootFoldersByCustomer
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE customer_id = $1 AND parent_id IS NULL
func (q *Queries) GetRootFoldersByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Folder, error) {
	rows, err := q.db.Query(ctx, getRootFoldersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenUsage = `-- name: GetTokenUsage :many
SELECT id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens, created_at FROM token_usage
WHERE customer_id = $1
`

// GetTokenUsage
//
//	SELECT id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens, created_at FROM token_usage
//	WHERE customer_id = $1
func (q *Queries) GetTokenUsage(ctx context.Context, customerID uuid.UUID) ([]*TokenUsage, error) {
	rows, err := q.db.Query(ctx, getTokenUsage, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TokenUsage{}
	for rows.Next() {
		var i TokenUsage
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ConversationID,
			&i.Model,
			&i.InputTokens,
			&i.OutputTokens,
			&i.TotalTokens,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnvalidatedDocumentsByCustomer = `-- name: GetUnvalidatedDocumentsByCustomer :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
WHERE customer_id = $1 AND validated = false
`

// GetUnvalidatedDocumentsByCustomer
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM document
//	WHERE customer_id = $1 AND validated = false
func (q *Queries) GetUnvalidatedDocumentsByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getUnvalidatedDocumentsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.VectorSha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVectorizeJob = `-- name: GetVectorizeJob :one
SELECT vj.id, vj.customer_id, vj.documents, vj.websites, vj.created_at, vj.updated_at, vji.status, vji.message, vji.error
FROM vectorize_job vj
JOIN vectorize_job_item vji ON vj.id = vji.job_id
WHERE vj.id = $1
ORDER BY vji.created_at DESC
LIMIT 1
`

type GetVectorizeJobRow struct {
	ID         uuid.UUID          `db:"id" json:"id"`
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	Documents  bool               `db:"documents" json:"documents"`
	Websites   bool               `db:"websites" json:"websites"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	Status     VectorizeJobStatus `db:"status" json:"status"`
	Message    string             `db:"message" json:"message"`
	Error      string             `db:"error" json:"error"`
}

// GetVectorizeJob
//
//	SELECT vj.id, vj.customer_id, vj.documents, vj.websites, vj.created_at, vj.updated_at, vji.status, vji.message, vji.error
//	FROM vectorize_job vj
//	JOIN vectorize_job_item vji ON vj.id = vji.job_id
//	WHERE vj.id = $1
//	ORDER BY vji.created_at DESC
//	LIMIT 1
func (q *Queries) GetVectorizeJob(ctx context.Context, id uuid.UUID) (*GetVectorizeJobRow, error) {
	row := q.db.QueryRow(ctx, getVectorizeJob, id)
	var i GetVectorizeJobRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Documents,
		&i.Websites,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Message,
		&i.Error,
	)
	return &i, err
}

const getVectorizeJobItems = `-- name: GetVectorizeJobItems :many
SELECT id, job_id, status, message, error, created_at, updated_at FROM vectorize_job_item
WHERE job_id = $1
`

// GetVectorizeJobItems
//
//	SELECT id, job_id, status, message, error, created_at, updated_at FROM vectorize_job_item
//	WHERE job_id = $1
func (q *Queries) GetVectorizeJobItems(ctx context.Context, jobID uuid.UUID) ([]*VectorizeJobItem, error) {
	rows, err := q.db.Query(ctx, getVectorizeJobItems, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VectorizeJobItem{}
	for rows.Next() {
		var i VectorizeJobItem
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.Message,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVectorizeJobsWaiting = `-- name: GetVectorizeJobsWaiting :many
SELECT id, customer_id, documents, websites, created_at, updated_at FROM vectorize_job vj
WHERE NOT EXISTS (
    SELECT 1
    FROM vectorize_job_item vji
    WHERE vj.id = vji.job_id
)
`

// GetVectorizeJobsWaiting
//
//	SELECT id, customer_id, documents, websites, created_at, updated_at FROM vectorize_job vj
//	WHERE NOT EXISTS (
//	    SELECT 1
//	    FROM vectorize_job_item vji
//	    WHERE vj.id = vji.job_id
//	)
func (q *Queries) GetVectorizeJobsWaiting(ctx context.Context) ([]*VectorizeJob, error) {
	rows, err := q.db.Query(ctx, getVectorizeJobsWaiting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VectorizeJob{}
	for rows.Next() {
		var i VectorizeJob
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Documents,
			&i.Websites,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebsite = `-- name: GetWebsite :one


SELECT id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at FROM website
WHERE id = $1
`

// -- name: QueryVectorStore :many
// SELECT
//
//	sqlc.embed(vs),
//	sqlc.embed(d),
//	sqlc.embed(wp)
//
// FROM vector_store vs
// LEFT JOIN document_vector dv ON dv.vector_store_id = vs.object_id
// LEFT JOIN document d ON d.id = dv.document_id
// LEFT JOIN folder f ON f.id = d.parent_id
// LEFT JOIN website_page_vector wpv ON wpv.vector_store_id = vs.object_id
// LEFT JOIN website_page wp ON wp.id = wpv.website_page_id
// LEFT JOIN website w ON wp.website_id = w.id
// WHERE vs.customer_id = $1
// ORDER BY vs.embeddings <#> $3
// LIMIT $2;
// -- name: QueryVectorStoreScoped :many
// SELECT
//
//	sqlc.embed(vs),
//	sqlc.embed(d),
//	sqlc.embed(wp)
//
// FROM vector_store vs
// JOIN document_vector dv ON dv.vector_store_id = vs.object_id
// JOIN document d ON d.id = dv.document_id
// JOIN folder f ON f.id = d.parent_id
// JOIN website_page_vector wpv ON wpv.vector_store_id = vs.object_id
// JOIN website_page wp ON wp.id = wpv.website_page_id
// JOIN website w ON wp.website_id = w.id
// WHERE vs.customer_id = $1
// AND (
//
//	($4::uuid[] IS NULL OR d.id = ANY($4::uuid[]))
//	OR
//	($5::uuid[] IS NULL OR f.id = ANY($5::uuid[]))
//	OR
//	($6::uuid[] IS NULL OR wp.id = ANY($6::uuid[]))
//	OR
//	($7::uuid[] IS NULL OR w.id = ANY($7::uuid[]))
//
// )
// ORDER BY vs.embeddings <#> $3
// LIMIT $2;
//
//	SELECT id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at FROM website
//	WHERE id = $1
func (q *Queries) GetWebsite(ctx context.Context, id uuid.UUID) (*Website, error) {
	row := q.db.QueryRow(ctx, getWebsite, id)
	var i Website
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Protocol,
		&i.Domain,
		&i.Blacklist,
		&i.Whitelist,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getWebsitePagesBySite = `-- name: GetWebsitePagesBySite :many
SELECT id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM website_page
WHERE website_id = $1
`

// GetWebsitePagesBySite
//
//	SELECT id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, vector_sha_256, created_at, updated_at FROM website_page
//	WHERE website_id = $1
func (q *Queries) GetWebsitePagesBySite(ctx context.Context, websiteID uuid.UUID) ([]*WebsitePage, error) {
	rows, err := q.db.Query(ctx, getWebsitePagesBySite, websiteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WebsitePage{}
	for rows.Next() {
		var i WebsitePage
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WebsiteID,
			&i.Url,
			&i.Sha256,
			&i.IsValid,
			&i.Metadata,
			&i.Summary,
			&i.SummarySha256,
			&i.VectorSha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebsitesByCustomer = `-- name: GetWebsitesByCustomer :many
SELECT id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at FROM website
WHERE customer_id = $1
`

// GetWebsitesByCustomer
//
//	SELECT id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at FROM website
//	WHERE customer_id = $1
func (q *Queries) GetWebsitesByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Website, error) {
	rows, err := q.db.Query(ctx, getWebsitesByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Website{}
	for rows.Next() {
		var i Website
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Protocol,
			&i.Domain,
			&i.Blacklist,
			&i.Whitelist,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebsitesByCustomerWithCount = `-- name: GetWebsitesByCustomerWithCount :many
SELECT w.id, w.customer_id, w.protocol, w.domain, w.blacklist, w.whitelist, w.created_at, w.updated_at, count(wp.*) as page_count FROM website w
JOIN website_page wp ON w.id = wp.website_id
WHERE w.customer_id = $1
GROUP BY w.id
`

type GetWebsitesByCustomerWithCountRow struct {
	ID         uuid.UUID          `db:"id" json:"id"`
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	Protocol   string             `db:"protocol" json:"protocol"`
	Domain     string             `db:"domain" json:"domain"`
	Blacklist  []string           `db:"blacklist" json:"blacklist"`
	Whitelist  []string           `db:"whitelist" json:"whitelist"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	PageCount  int64              `db:"page_count" json:"pageCount"`
}

// GetWebsitesByCustomerWithCount
//
//	SELECT w.id, w.customer_id, w.protocol, w.domain, w.blacklist, w.whitelist, w.created_at, w.updated_at, count(wp.*) as page_count FROM website w
//	JOIN website_page wp ON w.id = wp.website_id
//	WHERE w.customer_id = $1
//	GROUP BY w.id
func (q *Queries) GetWebsitesByCustomerWithCount(ctx context.Context, customerID uuid.UUID) ([]*GetWebsitesByCustomerWithCountRow, error) {
	rows, err := q.db.Query(ctx, getWebsitesByCustomerWithCount, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWebsitesByCustomerWithCountRow{}
	for rows.Next() {
		var i GetWebsitesByCustomerWithCountRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Protocol,
			&i.Domain,
			&i.Blacklist,
			&i.Whitelist,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, name, datastore, created_at, updated_at FROM customer
ORDER BY name
`

// ListCustomers
//
//	SELECT id, name, datastore, created_at, updated_at FROM customer
//	ORDER BY name
func (q *Queries) ListCustomers(ctx context.Context) ([]*Customer, error) {
	rows, err := q.db.Query(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Datastore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDocumentVectors = `-- name: ListDocumentVectors :many
SELECT id, document_id, vector_store_id, customer_id, index, metadata, created_at FROM document_vector
WHERE customer_id = $1
`

// ListDocumentVectors
//
//	SELECT id, document_id, vector_store_id, customer_id, index, metadata, created_at FROM document_vector
//	WHERE customer_id = $1
func (q *Queries) ListDocumentVectors(ctx context.Context, customerID uuid.UUID) ([]*DocumentVector, error) {
	rows, err := q.db.Query(ctx, listDocumentVectors, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DocumentVector{}
	for rows.Next() {
		var i DocumentVector
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.VectorStoreID,
			&i.CustomerID,
			&i.Index,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebsitePageVectors = `-- name: ListWebsitePageVectors :many
SELECT id, website_page_id, vector_store_id, customer_id, index, metadata, created_at FROM website_page_vector
WHERE customer_id = $1
`

// ListWebsitePageVectors
//
//	SELECT id, website_page_id, vector_store_id, customer_id, index, metadata, created_at FROM website_page_vector
//	WHERE customer_id = $1
func (q *Queries) ListWebsitePageVectors(ctx context.Context, customerID uuid.UUID) ([]*WebsitePageVector, error) {
	rows, err := q.db.Query(ctx, listWebsitePageVectors, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WebsitePageVector{}
	for rows.Next() {
		var i WebsitePageVector
		if err := rows.Scan(
			&i.ID,
			&i.WebsitePageID,
			&i.VectorStoreID,
			&i.CustomerID,
			&i.Index,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDocumentAsUploaded = `-- name: MarkDocumentAsUploaded :one
UPDATE document
SET validated = true
WHERE id = $1
RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at
`

// MarkDocumentAsUploaded
//
//	UPDATE document
//	SET validated = true
//	WHERE id = $1
//	RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at
func (q *Queries) MarkDocumentAsUploaded(ctx context.Context, id uuid.UUID) (*Document, error) {
	row := q.db.QueryRow(ctx, markDocumentAsUploaded, id)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Filename,
		&i.Type,
		&i.SizeBytes,
		&i.Sha256,
		&i.Validated,
		&i.DatastoreType,
		&i.DatastoreID,
		&i.Summary,
		&i.SummarySha256,
		&i.VectorSha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const queryVectorStoreDocuments = `-- name: QueryVectorStoreDocuments :many
SELECT d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.vector_sha_256, d.created_at, d.updated_at
FROM vector_store vs
JOIN document_vector dv ON vs.id = dv.vector_store_id
JOIN document d ON d.id = dv.document_id
WHERE vs.customer_id = $1
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreDocumentsParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
}

// QueryVectorStoreDocuments
//
//	SELECT d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.vector_sha_256, d.created_at, d.updated_at
//	FROM vector_store vs
//	JOIN document_vector dv ON vs.id = dv.vector_store_id
//	JOIN document d ON d.id = dv.document_id
//	WHERE vs.customer_id = $1
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreDocuments(ctx context.Context, arg *QueryVectorStoreDocumentsParams) ([]*Document, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreDocuments, arg.CustomerID, arg.Limit, arg.Embeddings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.VectorSha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreDocumentsScoped = `-- name: QueryVectorStoreDocumentsScoped :many
SELECT
    vs.id, vs.customer_id, vs.raw, vs.embeddings, vs.content_type, vs.object_id, vs.object_parent_id, vs.metadata, vs.created_at,
    d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.vector_sha_256, d.created_at, d.updated_at
FROM vector_store vs
JOIN document_vector dv ON vs.id = dv.vector_store_id
JOIN document d ON d.id = dv.document_id
LEFT JOIN folder f
ON CASE
        WHEN $5::uuid[] IS NOT NULL
        AND $5::uuid[] != '{}'
        AND f.id = ANY($5::uuid[])
        THEN f.id = d.parent_id
    END
AND ($4::uuid[] IS NULL OR d.id = ANY($4::uuid[]))
WHERE vs.customer_id = $1
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreDocumentsScopedParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
	Column4    []uuid.UUID      `db:"column_4" json:"column4"`
	Column5    []uuid.UUID      `db:"column_5" json:"column5"`
}

type QueryVectorStoreDocumentsScopedRow struct {
	VectorStore VectorStore `db:"vector_store" json:"vectorStore"`
	Document    Document    `db:"document" json:"document"`
}

// QueryVectorStoreDocumentsScoped
//
//	SELECT
//	    vs.id, vs.customer_id, vs.raw, vs.embeddings, vs.content_type, vs.object_id, vs.object_parent_id, vs.metadata, vs.created_at,
//	    d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.vector_sha_256, d.created_at, d.updated_at
//	FROM vector_store vs
//	JOIN document_vector dv ON vs.id = dv.vector_store_id
//	JOIN document d ON d.id = dv.document_id
//	LEFT JOIN folder f
//	ON CASE
//	        WHEN $5::uuid[] IS NOT NULL
//	        AND $5::uuid[] != '{}'
//	        AND f.id = ANY($5::uuid[])
//	        THEN f.id = d.parent_id
//	    END
//	AND ($4::uuid[] IS NULL OR d.id = ANY($4::uuid[]))
//	WHERE vs.customer_id = $1
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreDocumentsScoped(ctx context.Context, arg *QueryVectorStoreDocumentsScopedParams) ([]*QueryVectorStoreDocumentsScopedRow, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreDocumentsScoped,
		arg.CustomerID,
		arg.Limit,
		arg.Embeddings,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QueryVectorStoreDocumentsScopedRow{}
	for rows.Next() {
		var i QueryVectorStoreDocumentsScopedRow
		if err := rows.Scan(
			&i.VectorStore.ID,
			&i.VectorStore.CustomerID,
			&i.VectorStore.Raw,
			&i.VectorStore.Embeddings,
			&i.VectorStore.ContentType,
			&i.VectorStore.ObjectID,
			&i.VectorStore.ObjectParentID,
			&i.VectorStore.Metadata,
			&i.VectorStore.CreatedAt,
			&i.Document.ID,
			&i.Document.ParentID,
			&i.Document.CustomerID,
			&i.Document.Filename,
			&i.Document.Type,
			&i.Document.SizeBytes,
			&i.Document.Sha256,
			&i.Document.Validated,
			&i.Document.DatastoreType,
			&i.Document.DatastoreID,
			&i.Document.Summary,
			&i.Document.SummarySha256,
			&i.Document.VectorSha256,
			&i.Document.CreatedAt,
			&i.Document.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreRaw = `-- name: QueryVectorStoreRaw :many
SELECT id, customer_id, raw, embeddings, content_type, object_id, object_parent_id, metadata, created_at FROM vector_store
WHERE customer_id = $1
ORDER BY embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreRawParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
}

// QueryVectorStoreRaw
//
//	SELECT id, customer_id, raw, embeddings, content_type, object_id, object_parent_id, metadata, created_at FROM vector_store
//	WHERE customer_id = $1
//	ORDER BY embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreRaw(ctx context.Context, arg *QueryVectorStoreRawParams) ([]*VectorStore, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreRaw, arg.CustomerID, arg.Limit, arg.Embeddings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VectorStore{}
	for rows.Next() {
		var i VectorStore
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Raw,
			&i.Embeddings,
			&i.ContentType,
			&i.ObjectID,
			&i.ObjectParentID,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreWebsitePages = `-- name: QueryVectorStoreWebsitePages :many
SELECT
    vs.id, vs.customer_id, vs.raw, vs.embeddings, vs.content_type, vs.object_id, vs.object_parent_id, vs.metadata, vs.created_at,
    wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.vector_sha_256, wp.created_at, wp.updated_at
FROM vector_store vs
JOIN website_page_vector wpv ON vs.id = wpv.vector_store_id
JOIN website_page wp ON wp.id = wpv.website_page_id
WHERE vs.customer_id = $1
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreWebsitePagesParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
}

type QueryVectorStoreWebsitePagesRow struct {
	VectorStore VectorStore `db:"vector_store" json:"vectorStore"`
	WebsitePage WebsitePage `db:"website_page" json:"websitePage"`
}

// QueryVectorStoreWebsitePages
//
//	SELECT
//	    vs.id, vs.customer_id, vs.raw, vs.embeddings, vs.content_type, vs.object_id, vs.object_parent_id, vs.metadata, vs.created_at,
//	    wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.vector_sha_256, wp.created_at, wp.updated_at
//	FROM vector_store vs
//	JOIN website_page_vector wpv ON vs.id = wpv.vector_store_id
//	JOIN website_page wp ON wp.id = wpv.website_page_id
//	WHERE vs.customer_id = $1
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreWebsitePages(ctx context.Context, arg *QueryVectorStoreWebsitePagesParams) ([]*QueryVectorStoreWebsitePagesRow, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreWebsitePages, arg.CustomerID, arg.Limit, arg.Embeddings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QueryVectorStoreWebsitePagesRow{}
	for rows.Next() {
		var i QueryVectorStoreWebsitePagesRow
		if err := rows.Scan(
			&i.VectorStore.ID,
			&i.VectorStore.CustomerID,
			&i.VectorStore.Raw,
			&i.VectorStore.Embeddings,
			&i.VectorStore.ContentType,
			&i.VectorStore.ObjectID,
			&i.VectorStore.ObjectParentID,
			&i.VectorStore.Metadata,
			&i.VectorStore.CreatedAt,
			&i.WebsitePage.ID,
			&i.WebsitePage.CustomerID,
			&i.WebsitePage.WebsiteID,
			&i.WebsitePage.Url,
			&i.WebsitePage.Sha256,
			&i.WebsitePage.IsValid,
			&i.WebsitePage.Metadata,
			&i.WebsitePage.Summary,
			&i.WebsitePage.SummarySha256,
			&i.WebsitePage.VectorSha256,
			&i.WebsitePage.CreatedAt,
			&i.WebsitePage.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreWebsitePagesScoped = `-- name: QueryVectorStoreWebsitePagesScoped :many
SELECT
    vs.id, vs.customer_id, vs.raw, vs.embeddings, vs.content_type, vs.object_id, vs.object_parent_id, vs.metadata, vs.created_at,
    wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.vector_sha_256, wp.created_at, wp.updated_at
FROM vector_store vs
JOIN website_page_vector wpv ON vs.id = wpv.vector_store_id
JOIN website_page wp ON wp.id = wpv.website_page_id
JOIN website w ON w.id = wp.website_id
WHERE vs.customer_id = $1
AND (
    ($4::uuid[] IS NULL OR wp.id = ANY($4::uuid[]))
    OR
    ($5::uuid[] IS NULL OR w.id = ANY($5::uuid[]))
)
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreWebsitePagesScopedParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
	Column4    []uuid.UUID      `db:"column_4" json:"column4"`
	Column5    []uuid.UUID      `db:"column_5" json:"column5"`
}

type QueryVectorStoreWebsitePagesScopedRow struct {
	VectorStore VectorStore `db:"vector_store" json:"vectorStore"`
	WebsitePage WebsitePage `db:"website_page" json:"websitePage"`
}

// QueryVectorStoreWebsitePagesScoped
//
//	SELECT
//	    vs.id, vs.customer_id, vs.raw, vs.embeddings, vs.content_type, vs.object_id, vs.object_parent_id, vs.metadata, vs.created_at,
//	    wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.vector_sha_256, wp.created_at, wp.updated_at
//	FROM vector_store vs
//	JOIN website_page_vector wpv ON vs.id = wpv.vector_store_id
//	JOIN website_page wp ON wp.id = wpv.website_page_id
//	JOIN website w ON w.id = wp.website_id
//	WHERE vs.customer_id = $1
//	AND (
//	    ($4::uuid[] IS NULL OR wp.id = ANY($4::uuid[]))
//	    OR
//	    ($5::uuid[] IS NULL OR w.id = ANY($5::uuid[]))
//	)
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreWebsitePagesScoped(ctx context.Context, arg *QueryVectorStoreWebsitePagesScopedParams) ([]*QueryVectorStoreWebsitePagesScopedRow, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreWebsitePagesScoped,
		arg.CustomerID,
		arg.Limit,
		arg.Embeddings,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QueryVectorStoreWebsitePagesScopedRow{}
	for rows.Next() {
		var i QueryVectorStoreWebsitePagesScopedRow
		if err := rows.Scan(
			&i.VectorStore.ID,
			&i.VectorStore.CustomerID,
			&i.VectorStore.Raw,
			&i.VectorStore.Embeddings,
			&i.VectorStore.ContentType,
			&i.VectorStore.ObjectID,
			&i.VectorStore.ObjectParentID,
			&i.VectorStore.Metadata,
			&i.VectorStore.CreatedAt,
			&i.WebsitePage.ID,
			&i.WebsitePage.CustomerID,
			&i.WebsitePage.WebsiteID,
			&i.WebsitePage.Url,
			&i.WebsitePage.Sha256,
			&i.WebsitePage.IsValid,
			&i.WebsitePage.Metadata,
			&i.WebsitePage.Summary,
			&i.WebsitePage.SummarySha256,
			&i.WebsitePage.VectorSha256,
			&i.WebsitePage.CreatedAt,
			&i.WebsitePage.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setConversationError = `-- name: SetConversationError :one
UPDATE conversation SET
    has_error = true,
    error_message = $2
WHERE id = $1
RETURNING id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at
`

type SetConversationErrorParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	ErrorMessage *string   `db:"error_message" json:"errorMessage"`
}

// SetConversationError
//
//	UPDATE conversation SET
//	    has_error = true,
//	    error_message = $2
//	WHERE id = $1
//	RETURNING id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at
func (q *Queries) SetConversationError(ctx context.Context, arg *SetConversationErrorParams) (*Conversation, error) {
	row := q.db.QueryRow(ctx, setConversationError, arg.ID, arg.ErrorMessage)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.ConversationType,
		&i.SystemMessage,
		&i.Metadata,
		&i.HasError,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const setProjectIdeaUsed = `-- name: SetProjectIdeaUsed :one
UPDATE project_idea
    SET used = true
WHERE id = $1
RETURNING id, project_id, conversation_id, title, used, created_at, updated_at
`

// SetProjectIdeaUsed
//
//	UPDATE project_idea
//	    SET used = true
//	WHERE id = $1
//	RETURNING id, project_id, conversation_id, title, used, created_at, updated_at
func (q *Queries) SetProjectIdeaUsed(ctx context.Context, id uuid.UUID) (*ProjectIdea, error) {
	row := q.db.QueryRow(ctx, setProjectIdeaUsed, id)
	var i ProjectIdea
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConversationID,
		&i.Title,
		&i.Used,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const setWebsitePagesNotValid = `-- name: SetWebsitePagesNotValid :exec
UPDATE website_page SET
    updated_at = CURRENT_TIMESTAMP,
    is_valid = FALSE
WHERE customer_id = $1
AND website_id = $2
`

type SetWebsitePagesNotValidParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	WebsiteID  uuid.UUID `db:"website_id" json:"websiteId"`
}

// SetWebsitePagesNotValid
//
//	UPDATE website_page SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    is_valid = FALSE
//	WHERE customer_id = $1
//	AND website_id = $2
func (q *Queries) SetWebsitePagesNotValid(ctx context.Context, arg *SetWebsitePagesNotValidParams) error {
	_, err := q.db.Exec(ctx, setWebsitePagesNotValid, arg.CustomerID, arg.WebsiteID)
	return err
}

const touchDocument = `-- name: TouchDocument :exec
UPDATE document SET
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// TouchDocument
//
//	UPDATE document SET
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) TouchDocument(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, touchDocument, id)
	return err
}

const touchWebsitePage = `-- name: TouchWebsitePage :exec
UPDATE website_page SET
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// TouchWebsitePage
//
//	UPDATE website_page SET
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) TouchWebsitePage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, touchWebsitePage, id)
	return err
}

const updateConversationTitle = `-- name: UpdateConversationTitle :one
UPDATE conversation SET
    title = $2
WHERE id = $1
RETURNING id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at
`

type UpdateConversationTitleParams struct {
	ID    uuid.UUID `db:"id" json:"id"`
	Title string    `db:"title" json:"title"`
}

// UpdateConversationTitle
//
//	UPDATE conversation SET
//	    title = $2
//	WHERE id = $1
//	RETURNING id, customer_id, title, conversation_type, system_message, metadata, has_error, error_message, created_at, updated_at
func (q *Queries) UpdateConversationTitle(ctx context.Context, arg *UpdateConversationTitleParams) (*Conversation, error) {
	row := q.db.QueryRow(ctx, updateConversationTitle, arg.ID, arg.Title)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.ConversationType,
		&i.SystemMessage,
		&i.Metadata,
		&i.HasError,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateCustomer = `-- name: UpdateCustomer :exec
UPDATE customer
    set name = $2
WHERE id = $1
RETURNING id, name, datastore, created_at, updated_at
`

type UpdateCustomerParams struct {
	ID   uuid.UUID `db:"id" json:"id"`
	Name string    `db:"name" json:"name"`
}

// UpdateCustomer
//
//	UPDATE customer
//	    set name = $2
//	WHERE id = $1
//	RETURNING id, name, datastore, created_at, updated_at
func (q *Queries) UpdateCustomer(ctx context.Context, arg *UpdateCustomerParams) error {
	_, err := q.db.Exec(ctx, updateCustomer, arg.ID, arg.Name)
	return err
}

const updateCustomerChatLLM = `-- name: UpdateCustomerChatLLM :one
UPDATE customer_llm_configurations SET
    chat_llm_id = $2
WHERE customer_id = $1
RETURNING customer_id, summary_llm_id, chat_llm_id, created_at, updated_at
`

type UpdateCustomerChatLLMParams struct {
	CustomerID uuid.UUID   `db:"customer_id" json:"customerId"`
	ChatLlmID  pgtype.UUID `db:"chat_llm_id" json:"chatLlmId"`
}

// UpdateCustomerChatLLM
//
//	UPDATE customer_llm_configurations SET
//	    chat_llm_id = $2
//	WHERE customer_id = $1
//	RETURNING customer_id, summary_llm_id, chat_llm_id, created_at, updated_at
func (q *Queries) UpdateCustomerChatLLM(ctx context.Context, arg *UpdateCustomerChatLLMParams) (*CustomerLlmConfiguration, error) {
	row := q.db.QueryRow(ctx, updateCustomerChatLLM, arg.CustomerID, arg.ChatLlmID)
	var i CustomerLlmConfiguration
	err := row.Scan(
		&i.CustomerID,
		&i.SummaryLlmID,
		&i.ChatLlmID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateCustomerSummaryLLM = `-- name: UpdateCustomerSummaryLLM :one
UPDATE customer_llm_configurations SET
    summary_llm_id = $2
WHERE customer_id = $1
RETURNING customer_id, summary_llm_id, chat_llm_id, created_at, updated_at
`

type UpdateCustomerSummaryLLMParams struct {
	CustomerID   uuid.UUID   `db:"customer_id" json:"customerId"`
	SummaryLlmID pgtype.UUID `db:"summary_llm_id" json:"summaryLlmId"`
}

// UpdateCustomerSummaryLLM
//
//	UPDATE customer_llm_configurations SET
//	    summary_llm_id = $2
//	WHERE customer_id = $1
//	RETURNING customer_id, summary_llm_id, chat_llm_id, created_at, updated_at
func (q *Queries) UpdateCustomerSummaryLLM(ctx context.Context, arg *UpdateCustomerSummaryLLMParams) (*CustomerLlmConfiguration, error) {
	row := q.db.QueryRow(ctx, updateCustomerSummaryLLM, arg.CustomerID, arg.SummaryLlmID)
	var i CustomerLlmConfiguration
	err := row.Scan(
		&i.CustomerID,
		&i.SummaryLlmID,
		&i.ChatLlmID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateDocumentSummary = `-- name: UpdateDocumentSummary :one
UPDATE document SET
    updated_at = CURRENT_TIMESTAMP,
    summary = $2,
    summary_sha_256 = $3
WHERE id = $1
RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at
`

type UpdateDocumentSummaryParams struct {
	ID            uuid.UUID `db:"id" json:"id"`
	Summary       string    `db:"summary" json:"summary"`
	SummarySha256 string    `db:"summary_sha_256" json:"summarySha256"`
}

// UpdateDocumentSummary
//
//	UPDATE document SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    summary = $2,
//	    summary_sha_256 = $3
//	WHERE id = $1
//	RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, vector_sha_256, created_at, updated_at
func (q *Queries) UpdateDocumentSummary(ctx context.Context, arg *UpdateDocumentSummaryParams) (*Document, error) {
	row := q.db.QueryRow(ctx, updateDocumentSummary, arg.ID, arg.Summary, arg.SummarySha256)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Filename,
		&i.Type,
		&i.SizeBytes,
		&i.Sha256,
		&i.Validated,
		&i.DatastoreType,
		&i.DatastoreID,
		&i.Summary,
		&i.SummarySha256,
		&i.VectorSha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateDocumentVectorSig = `-- name: UpdateDocumentVectorSig :exec
UPDATE document SET
    updated_at = CURRENT_TIMESTAMP,
    vector_sha_256 = $2
WHERE id = $1
`

type UpdateDocumentVectorSigParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	VectorSha256 string    `db:"vector_sha_256" json:"vectorSha256"`
}

// UpdateDocumentVectorSig
//
//	UPDATE document SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    vector_sha_256 = $2
//	WHERE id = $1
func (q *Queries) UpdateDocumentVectorSig(ctx context.Context, arg *UpdateDocumentVectorSigParams) error {
	_, err := q.db.Exec(ctx, updateDocumentVectorSig, arg.ID, arg.VectorSha256)
	return err
}

const updateLLM = `-- name: UpdateLLM :one
UPDATE llm SET
    title = $2,
    model = $3,
    temperature = $4,
    instructions = $5
WHERE id = $1
RETURNING id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at
`

type UpdateLLMParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	Title        string    `db:"title" json:"title"`
	Model        string    `db:"model" json:"model"`
	Temperature  float64   `db:"temperature" json:"temperature"`
	Instructions string    `db:"instructions" json:"instructions"`
}

// UpdateLLM
//
//	UPDATE llm SET
//	    title = $2,
//	    model = $3,
//	    temperature = $4,
//	    instructions = $5
//	WHERE id = $1
//	RETURNING id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at
func (q *Queries) UpdateLLM(ctx context.Context, arg *UpdateLLMParams) (*Llm, error) {
	row := q.db.QueryRow(ctx, updateLLM,
		arg.ID,
		arg.Title,
		arg.Model,
		arg.Temperature,
		arg.Instructions,
	)
	var i Llm
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Color,
		&i.Model,
		&i.Temperature,
		&i.Instructions,
		&i.IsDefault,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateWebsitePageSignature = `-- name: UpdateWebsitePageSignature :one
UPDATE website_page SET
    updated_at = CURRENT_TIMESTAMP,
    sha_256 = $2
WHERE id = $1
RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, vector_sha_256, created_at, updated_at
`

type UpdateWebsitePageSignatureParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	Sha256 string    `db:"sha_256" json:"sha256"`
}

// UpdateWebsitePageSignature
//
//	UPDATE website_page SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    sha_256 = $2
//	WHERE id = $1
//	RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, vector_sha_256, created_at, updated_at
func (q *Queries) UpdateWebsitePageSignature(ctx context.Context, arg *UpdateWebsitePageSignatureParams) (*WebsitePage, error) {
	row := q.db.QueryRow(ctx, updateWebsitePageSignature, arg.ID, arg.Sha256)
	var i WebsitePage
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WebsiteID,
		&i.Url,
		&i.Sha256,
		&i.IsValid,
		&i.Metadata,
		&i.Summary,
		&i.SummarySha256,
		&i.VectorSha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateWebsitePageSummary = `-- name: UpdateWebsitePageSummary :one
UPDATE website_page SET
    updated_at = CURRENT_TIMESTAMP,
    summary = $2,
    summary_sha_256 = $3
WHERE id = $1
RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, vector_sha_256, created_at, updated_at
`

type UpdateWebsitePageSummaryParams struct {
	ID            uuid.UUID `db:"id" json:"id"`
	Summary       string    `db:"summary" json:"summary"`
	SummarySha256 string    `db:"summary_sha_256" json:"summarySha256"`
}

// UpdateWebsitePageSummary
//
//	UPDATE website_page SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    summary = $2,
//	    summary_sha_256 = $3
//	WHERE id = $1
//	RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, vector_sha_256, created_at, updated_at
func (q *Queries) UpdateWebsitePageSummary(ctx context.Context, arg *UpdateWebsitePageSummaryParams) (*WebsitePage, error) {
	row := q.db.QueryRow(ctx, updateWebsitePageSummary, arg.ID, arg.Summary, arg.SummarySha256)
	var i WebsitePage
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WebsiteID,
		&i.Url,
		&i.Sha256,
		&i.IsValid,
		&i.Metadata,
		&i.Summary,
		&i.SummarySha256,
		&i.VectorSha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateWebsitePageVectorSig = `-- name: UpdateWebsitePageVectorSig :exec
UPDATE website_page SET
    updated_at = CURRENT_TIMESTAMP,
    vector_sha_256 = $2
WHERE id = $1
`

type UpdateWebsitePageVectorSigParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	VectorSha256 string    `db:"vector_sha_256" json:"vectorSha256"`
}

// UpdateWebsitePageVectorSig
//
//	UPDATE website_page SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    vector_sha_256 = $2
//	WHERE id = $1
func (q *Queries) UpdateWebsitePageVectorSig(ctx context.Context, arg *UpdateWebsitePageVectorSigParams) error {
	_, err := q.db.Exec(ctx, updateWebsitePageVectorSig, arg.ID, arg.VectorSha256)
	return err
}
