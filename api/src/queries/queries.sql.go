// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const clearConversation = `-- name: ClearConversation :exec
DELETE FROM conversation_message
WHERE conversation_id = $1
`

// ClearConversation
//
//	DELETE FROM conversation_message
//	WHERE conversation_id = $1
func (q *Queries) ClearConversation(ctx context.Context, conversationID uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearConversation, conversationID)
	return err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversation (
    customer_id, title, conversation_type, system_message, metadata
) VALUES ( $1, $2, $3, $4, $5 )
RETURNING id, customer_id, title, conversation_type, system_message, metadata, created_at, updated_at
`

type CreateConversationParams struct {
	CustomerID       uuid.UUID `db:"customer_id" json:"customerId"`
	Title            string    `db:"title" json:"title"`
	ConversationType string    `db:"conversation_type" json:"conversationType"`
	SystemMessage    string    `db:"system_message" json:"systemMessage"`
	Metadata         []byte    `db:"metadata" json:"metadata"`
}

// CreateConversation
//
//	INSERT INTO conversation (
//	    customer_id, title, conversation_type, system_message, metadata
//	) VALUES ( $1, $2, $3, $4, $5 )
//	RETURNING id, customer_id, title, conversation_type, system_message, metadata, created_at, updated_at
func (q *Queries) CreateConversation(ctx context.Context, arg *CreateConversationParams) (*Conversation, error) {
	row := q.db.QueryRow(ctx, createConversation,
		arg.CustomerID,
		arg.Title,
		arg.ConversationType,
		arg.SystemMessage,
		arg.Metadata,
	)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.ConversationType,
		&i.SystemMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createConversationMessage = `-- name: CreateConversationMessage :one
INSERT INTO conversation_message (
    conversation_id,
    llm_id,
    model,
    temperature,
    instructions,
    role,
    message,
    index,
    tool_use_id,
    tool_name,
    tool_arguments
) VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11 )
ON CONFLICT (conversation_id, index)
DO UPDATE SET
    updated_at = CURRENT_TIMESTAMP
RETURNING id, conversation_id, llm_id, model, temperature, instructions, role, message, index, tool_use_id, tool_name, tool_arguments, created_at, updated_at
`

type CreateConversationMessageParams struct {
	ConversationID uuid.UUID   `db:"conversation_id" json:"conversationId"`
	LlmID          pgtype.UUID `db:"llm_id" json:"llmId"`
	Model          string      `db:"model" json:"model"`
	Temperature    float64     `db:"temperature" json:"temperature"`
	Instructions   string      `db:"instructions" json:"instructions"`
	Role           string      `db:"role" json:"role"`
	Message        string      `db:"message" json:"message"`
	Index          int32       `db:"index" json:"index"`
	ToolUseID      string      `db:"tool_use_id" json:"toolUseId"`
	ToolName       string      `db:"tool_name" json:"toolName"`
	ToolArguments  []byte      `db:"tool_arguments" json:"toolArguments"`
}

// CreateConversationMessage
//
//	INSERT INTO conversation_message (
//	    conversation_id,
//	    llm_id,
//	    model,
//	    temperature,
//	    instructions,
//	    role,
//	    message,
//	    index,
//	    tool_use_id,
//	    tool_name,
//	    tool_arguments
//	) VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11 )
//	ON CONFLICT (conversation_id, index)
//	DO UPDATE SET
//	    updated_at = CURRENT_TIMESTAMP
//	RETURNING id, conversation_id, llm_id, model, temperature, instructions, role, message, index, tool_use_id, tool_name, tool_arguments, created_at, updated_at
func (q *Queries) CreateConversationMessage(ctx context.Context, arg *CreateConversationMessageParams) (*ConversationMessage, error) {
	row := q.db.QueryRow(ctx, createConversationMessage,
		arg.ConversationID,
		arg.LlmID,
		arg.Model,
		arg.Temperature,
		arg.Instructions,
		arg.Role,
		arg.Message,
		arg.Index,
		arg.ToolUseID,
		arg.ToolName,
		arg.ToolArguments,
	)
	var i ConversationMessage
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.LlmID,
		&i.Model,
		&i.Temperature,
		&i.Instructions,
		&i.Role,
		&i.Message,
		&i.Index,
		&i.ToolUseID,
		&i.ToolName,
		&i.ToolArguments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customer (
    name
) VALUES (
    $1
)
RETURNING id, name, datastore, created_at, updated_at
`

// CreateCustomer
//
//	INSERT INTO customer (
//	    name
//	) VALUES (
//	    $1
//	)
//	RETURNING id, name, datastore, created_at, updated_at
func (q *Queries) CreateCustomer(ctx context.Context, name string) (*Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer, name)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Datastore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createDocument = `-- name: CreateDocument :one
INSERT INTO document (
    parent_id, customer_id, filename, type, size_bytes, sha_256, datastore_type, datastore_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (customer_id, parent_id, filename) DO UPDATE
SET updated_at = CURRENT_TIMESTAMP
RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at
`

type CreateDocumentParams struct {
	ParentID      pgtype.UUID `db:"parent_id" json:"parentId"`
	CustomerID    uuid.UUID   `db:"customer_id" json:"customerId"`
	Filename      string      `db:"filename" json:"filename"`
	Type          string      `db:"type" json:"type"`
	SizeBytes     int64       `db:"size_bytes" json:"sizeBytes"`
	Sha256        string      `db:"sha_256" json:"sha256"`
	DatastoreType string      `db:"datastore_type" json:"datastoreType"`
	DatastoreID   string      `db:"datastore_id" json:"datastoreId"`
}

// CreateDocument
//
//	INSERT INTO document (
//	    parent_id, customer_id, filename, type, size_bytes, sha_256, datastore_type, datastore_id
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8
//	)
//	ON CONFLICT (customer_id, parent_id, filename) DO UPDATE
//	SET updated_at = CURRENT_TIMESTAMP
//	RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at
func (q *Queries) CreateDocument(ctx context.Context, arg *CreateDocumentParams) (*Document, error) {
	row := q.db.QueryRow(ctx, createDocument,
		arg.ParentID,
		arg.CustomerID,
		arg.Filename,
		arg.Type,
		arg.SizeBytes,
		arg.Sha256,
		arg.DatastoreType,
		arg.DatastoreID,
	)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Filename,
		&i.Type,
		&i.SizeBytes,
		&i.Sha256,
		&i.Validated,
		&i.DatastoreType,
		&i.DatastoreID,
		&i.Summary,
		&i.SummarySha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createDocumentVector = `-- name: CreateDocumentVector :one
INSERT INTO document_vector (
    document_id, vector_store_id, customer_id, index, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, document_id, vector_store_id, customer_id, index, metadata, created_at
`

type CreateDocumentVectorParams struct {
	DocumentID    uuid.UUID `db:"document_id" json:"documentId"`
	VectorStoreID uuid.UUID `db:"vector_store_id" json:"vectorStoreId"`
	CustomerID    uuid.UUID `db:"customer_id" json:"customerId"`
	Index         int32     `db:"index" json:"index"`
	Metadata      []byte    `db:"metadata" json:"metadata"`
}

// CreateDocumentVector
//
//	INSERT INTO document_vector (
//	    document_id, vector_store_id, customer_id, index, metadata
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	RETURNING id, document_id, vector_store_id, customer_id, index, metadata, created_at
func (q *Queries) CreateDocumentVector(ctx context.Context, arg *CreateDocumentVectorParams) (*DocumentVector, error) {
	row := q.db.QueryRow(ctx, createDocumentVector,
		arg.DocumentID,
		arg.VectorStoreID,
		arg.CustomerID,
		arg.Index,
		arg.Metadata,
	)
	var i DocumentVector
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.VectorStoreID,
		&i.CustomerID,
		&i.Index,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const createFolder = `-- name: CreateFolder :one
INSERT INTO folder (
    parent_id, customer_id, title
) VALUES (
    $1, $2, $3
)
ON CONFLICT (customer_id, parent_id, title) DO UPDATE
SET updated_at = CURRENT_TIMESTAMP
RETURNING id, parent_id, customer_id, title, created_at, updated_at
`

type CreateFolderParams struct {
	ParentID   pgtype.UUID `db:"parent_id" json:"parentId"`
	CustomerID uuid.UUID   `db:"customer_id" json:"customerId"`
	Title      string      `db:"title" json:"title"`
}

// CreateFolder
//
//	INSERT INTO folder (
//	    parent_id, customer_id, title
//	) VALUES (
//	    $1, $2, $3
//	)
//	ON CONFLICT (customer_id, parent_id, title) DO UPDATE
//	SET updated_at = CURRENT_TIMESTAMP
//	RETURNING id, parent_id, customer_id, title, created_at, updated_at
func (q *Queries) CreateFolder(ctx context.Context, arg *CreateFolderParams) (*Folder, error) {
	row := q.db.QueryRow(ctx, createFolder, arg.ParentID, arg.CustomerID, arg.Title)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createFolderRoot = `-- name: CreateFolderRoot :one
INSERT INTO folder (
    customer_id, title
) VALUES (
    $1, 'root'
)
ON CONFLICT (customer_id, parent_id, title) DO UPDATE
SET updated_at = CURRENT_TIMESTAMP
RETURNING id, parent_id, customer_id, title, created_at, updated_at
`

// CreateFolderRoot
//
//	INSERT INTO folder (
//	    customer_id, title
//	) VALUES (
//	    $1, 'root'
//	)
//	ON CONFLICT (customer_id, parent_id, title) DO UPDATE
//	SET updated_at = CURRENT_TIMESTAMP
//	RETURNING id, parent_id, customer_id, title, created_at, updated_at
func (q *Queries) CreateFolderRoot(ctx context.Context, customerID uuid.UUID) (*Folder, error) {
	row := q.db.QueryRow(ctx, createFolderRoot, customerID)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createLLM = `-- name: CreateLLM :one
INSERT INTO llm (
    customer_id, title, model, temperature, instructions, is_default
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at
`

type CreateLLMParams struct {
	CustomerID   pgtype.UUID `db:"customer_id" json:"customerId"`
	Title        string      `db:"title" json:"title"`
	Model        string      `db:"model" json:"model"`
	Temperature  float64     `db:"temperature" json:"temperature"`
	Instructions string      `db:"instructions" json:"instructions"`
	IsDefault    bool        `db:"is_default" json:"isDefault"`
}

// CreateLLM
//
//	INSERT INTO llm (
//	    customer_id, title, model, temperature, instructions, is_default
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6
//	)
//	RETURNING id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at
func (q *Queries) CreateLLM(ctx context.Context, arg *CreateLLMParams) (*Llm, error) {
	row := q.db.QueryRow(ctx, createLLM,
		arg.CustomerID,
		arg.Title,
		arg.Model,
		arg.Temperature,
		arg.Instructions,
		arg.IsDefault,
	)
	var i Llm
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Color,
		&i.Model,
		&i.Temperature,
		&i.Instructions,
		&i.IsDefault,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createLinkedInPost = `-- name: CreateLinkedInPost :one
INSERT INTO linkedin_post(
    project_id, project_library_id, project_idea_id, title
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at
`

type CreateLinkedInPostParams struct {
	ProjectID        uuid.UUID   `db:"project_id" json:"projectId"`
	ProjectLibraryID uuid.UUID   `db:"project_library_id" json:"projectLibraryId"`
	ProjectIdeaID    pgtype.UUID `db:"project_idea_id" json:"projectIdeaId"`
	Title            string      `db:"title" json:"title"`
}

// CreateLinkedInPost
//
//	INSERT INTO linkedin_post(
//	    project_id, project_library_id, project_idea_id, title
//	) VALUES (
//	    $1, $2, $3, $4
//	)
//	RETURNING id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at
func (q *Queries) CreateLinkedInPost(ctx context.Context, arg *CreateLinkedInPostParams) (*LinkedinPost, error) {
	row := q.db.QueryRow(ctx, createLinkedInPost,
		arg.ProjectID,
		arg.ProjectLibraryID,
		arg.ProjectIdeaID,
		arg.Title,
	)
	var i LinkedinPost
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectLibraryID,
		&i.ProjectIdeaID,
		&i.Title,
		&i.AssetID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createLinkedInPostConfig = `-- name: CreateLinkedInPostConfig :one
INSERT INTO linkedin_post_config (
    project_id, linkedin_post_id,
    min_sections, max_sections, num_documents, num_website_pages,
    llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (linkedin_post_id)
DO UPDATE SET
    min_sections = EXCLUDED.min_sections,
    max_sections = EXCLUDED.max_sections,
    num_documents = EXCLUDED.num_documents,
    num_website_pages = EXCLUDED.num_website_pages,
    llm_content_generation_id = EXCLUDED.llm_content_generation_id,
    llm_vector_summarization_id = EXCLUDED.llm_vector_summarization_id,
    llm_website_summarization_id = EXCLUDED.llm_website_summarization_id,
    llm_proof_reading_id = EXCLUDED.llm_proof_reading_id
RETURNING id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at
`

type CreateLinkedInPostConfigParams struct {
	ProjectID                 pgtype.UUID `db:"project_id" json:"projectId"`
	LinkedinPostID            pgtype.UUID `db:"linkedin_post_id" json:"linkedinPostId"`
	MinSections               int32       `db:"min_sections" json:"minSections"`
	MaxSections               int32       `db:"max_sections" json:"maxSections"`
	NumDocuments              int32       `db:"num_documents" json:"numDocuments"`
	NumWebsitePages           int32       `db:"num_website_pages" json:"numWebsitePages"`
	LlmContentGenerationID    pgtype.UUID `db:"llm_content_generation_id" json:"llmContentGenerationId"`
	LlmVectorSummarizationID  pgtype.UUID `db:"llm_vector_summarization_id" json:"llmVectorSummarizationId"`
	LlmWebsiteSummarizationID pgtype.UUID `db:"llm_website_summarization_id" json:"llmWebsiteSummarizationId"`
	LlmProofReadingID         pgtype.UUID `db:"llm_proof_reading_id" json:"llmProofReadingId"`
}

// CreateLinkedInPostConfig
//
//	INSERT INTO linkedin_post_config (
//	    project_id, linkedin_post_id,
//	    min_sections, max_sections, num_documents, num_website_pages,
//	    llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
//	)
//	ON CONFLICT (linkedin_post_id)
//	DO UPDATE SET
//	    min_sections = EXCLUDED.min_sections,
//	    max_sections = EXCLUDED.max_sections,
//	    num_documents = EXCLUDED.num_documents,
//	    num_website_pages = EXCLUDED.num_website_pages,
//	    llm_content_generation_id = EXCLUDED.llm_content_generation_id,
//	    llm_vector_summarization_id = EXCLUDED.llm_vector_summarization_id,
//	    llm_website_summarization_id = EXCLUDED.llm_website_summarization_id,
//	    llm_proof_reading_id = EXCLUDED.llm_proof_reading_id
//	RETURNING id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at
func (q *Queries) CreateLinkedInPostConfig(ctx context.Context, arg *CreateLinkedInPostConfigParams) (*LinkedinPostConfig, error) {
	row := q.db.QueryRow(ctx, createLinkedInPostConfig,
		arg.ProjectID,
		arg.LinkedinPostID,
		arg.MinSections,
		arg.MaxSections,
		arg.NumDocuments,
		arg.NumWebsitePages,
		arg.LlmContentGenerationID,
		arg.LlmVectorSummarizationID,
		arg.LlmWebsiteSummarizationID,
		arg.LlmProofReadingID,
	)
	var i LinkedinPostConfig
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.LinkedinPostID,
		&i.MinSections,
		&i.MaxSections,
		&i.NumDocuments,
		&i.NumWebsitePages,
		&i.LlmContentGenerationID,
		&i.LlmVectorSummarizationID,
		&i.LlmWebsiteSummarizationID,
		&i.LlmProofReadingID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO project (
    customer_id, title, topic, idea_generation_model_id
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at
`

type CreateProjectParams struct {
	CustomerID            uuid.UUID   `db:"customer_id" json:"customerId"`
	Title                 string      `db:"title" json:"title"`
	Topic                 string      `db:"topic" json:"topic"`
	IdeaGenerationModelID pgtype.UUID `db:"idea_generation_model_id" json:"ideaGenerationModelId"`
}

// CreateProject
//
//	INSERT INTO project (
//	    customer_id, title, topic, idea_generation_model_id
//	) VALUES (
//	    $1, $2, $3, $4
//	)
//	RETURNING id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at
func (q *Queries) CreateProject(ctx context.Context, arg *CreateProjectParams) (*Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.CustomerID,
		arg.Title,
		arg.Topic,
		arg.IdeaGenerationModelID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Topic,
		&i.IdeaGenerationModelID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createProjectIdea = `-- name: CreateProjectIdea :one
INSERT INTO project_idea (
    project_id, conversation_id, title, used
) VALUES (
    $1, $2, $3, FALSE
)
RETURNING id, project_id, conversation_id, title, used, created_at, updated_at
`

type CreateProjectIdeaParams struct {
	ProjectID      uuid.UUID   `db:"project_id" json:"projectId"`
	ConversationID pgtype.UUID `db:"conversation_id" json:"conversationId"`
	Title          string      `db:"title" json:"title"`
}

// CreateProjectIdea
//
//	INSERT INTO project_idea (
//	    project_id, conversation_id, title, used
//	) VALUES (
//	    $1, $2, $3, FALSE
//	)
//	RETURNING id, project_id, conversation_id, title, used, created_at, updated_at
func (q *Queries) CreateProjectIdea(ctx context.Context, arg *CreateProjectIdeaParams) (*ProjectIdea, error) {
	row := q.db.QueryRow(ctx, createProjectIdea, arg.ProjectID, arg.ConversationID, arg.Title)
	var i ProjectIdea
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConversationID,
		&i.Title,
		&i.Used,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createProjectLibraryRecord = `-- name: CreateProjectLibraryRecord :one
INSERT INTO project_library (
    project_id, title, content_type
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, title, content_type, draft, published, created_at, updated_at
`

type CreateProjectLibraryRecordParams struct {
	ProjectID   uuid.UUID `db:"project_id" json:"projectId"`
	Title       string    `db:"title" json:"title"`
	ContentType string    `db:"content_type" json:"contentType"`
}

// CreateProjectLibraryRecord
//
//	INSERT INTO project_library (
//	    project_id, title, content_type
//	) VALUES (
//	    $1, $2, $3
//	)
//	RETURNING id, project_id, title, content_type, draft, published, created_at, updated_at
func (q *Queries) CreateProjectLibraryRecord(ctx context.Context, arg *CreateProjectLibraryRecordParams) (*ProjectLibrary, error) {
	row := q.db.QueryRow(ctx, createProjectLibraryRecord, arg.ProjectID, arg.Title, arg.ContentType)
	var i ProjectLibrary
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.ContentType,
		&i.Draft,
		&i.Published,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createTokenUsage = `-- name: CreateTokenUsage :one
INSERT INTO token_usage (
    id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (id)
DO UPDATE SET
    customer_id = EXCLUDED.customer_id,
    conversation_id = EXCLUDED.conversation_id,
    model = EXCLUDED.model,
    input_tokens = EXCLUDED.input_tokens,
    output_tokens = EXCLUDED.output_tokens,
    total_tokens = EXCLUDED.total_tokens
RETURNING id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens, created_at
`

type CreateTokenUsageParams struct {
	ID             uuid.UUID   `db:"id" json:"id"`
	CustomerID     uuid.UUID   `db:"customer_id" json:"customerId"`
	ConversationID pgtype.UUID `db:"conversation_id" json:"conversationId"`
	Model          string      `db:"model" json:"model"`
	InputTokens    int32       `db:"input_tokens" json:"inputTokens"`
	OutputTokens   int32       `db:"output_tokens" json:"outputTokens"`
	TotalTokens    int32       `db:"total_tokens" json:"totalTokens"`
}

// CreateTokenUsage
//
//	INSERT INTO token_usage (
//	    id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7
//	)
//	ON CONFLICT (id)
//	DO UPDATE SET
//	    customer_id = EXCLUDED.customer_id,
//	    conversation_id = EXCLUDED.conversation_id,
//	    model = EXCLUDED.model,
//	    input_tokens = EXCLUDED.input_tokens,
//	    output_tokens = EXCLUDED.output_tokens,
//	    total_tokens = EXCLUDED.total_tokens
//	RETURNING id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens, created_at
func (q *Queries) CreateTokenUsage(ctx context.Context, arg *CreateTokenUsageParams) (*TokenUsage, error) {
	row := q.db.QueryRow(ctx, createTokenUsage,
		arg.ID,
		arg.CustomerID,
		arg.ConversationID,
		arg.Model,
		arg.InputTokens,
		arg.OutputTokens,
		arg.TotalTokens,
	)
	var i TokenUsage
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ConversationID,
		&i.Model,
		&i.InputTokens,
		&i.OutputTokens,
		&i.TotalTokens,
		&i.CreatedAt,
	)
	return &i, err
}

const createVector = `-- name: CreateVector :one
INSERT INTO vector_store (
    customer_id, raw, embeddings, content_type, object_id, object_parent_id, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id
`

type CreateVectorParams struct {
	CustomerID     uuid.UUID        `db:"customer_id" json:"customerId"`
	Raw            string           `db:"raw" json:"raw"`
	Embeddings     *pgvector.Vector `db:"embeddings" json:"embeddings"`
	ContentType    string           `db:"content_type" json:"contentType"`
	ObjectID       uuid.UUID        `db:"object_id" json:"objectId"`
	ObjectParentID pgtype.UUID      `db:"object_parent_id" json:"objectParentId"`
	Metadata       []byte           `db:"metadata" json:"metadata"`
}

// CreateVector
//
//	INSERT INTO vector_store (
//	    customer_id, raw, embeddings, content_type, object_id, object_parent_id, metadata
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7
//	)
//	RETURNING id
func (q *Queries) CreateVector(ctx context.Context, arg *CreateVectorParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createVector,
		arg.CustomerID,
		arg.Raw,
		arg.Embeddings,
		arg.ContentType,
		arg.ObjectID,
		arg.ObjectParentID,
		arg.Metadata,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createWebsite = `-- name: CreateWebsite :one
INSERT INTO website (
    customer_id, protocol, domain, blacklist, whitelist
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT ON CONSTRAINT cnst_unique_website
DO UPDATE SET
    updated_at = CURRENT_TIMESTAMP,
    blacklist = EXCLUDED.blacklist,
    whitelist = EXCLUDED.whitelist
RETURNING id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at
`

type CreateWebsiteParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	Protocol   string    `db:"protocol" json:"protocol"`
	Domain     string    `db:"domain" json:"domain"`
	Blacklist  []string  `db:"blacklist" json:"blacklist"`
	Whitelist  []string  `db:"whitelist" json:"whitelist"`
}

// CreateWebsite
//
//	INSERT INTO website (
//	    customer_id, protocol, domain, blacklist, whitelist
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	ON CONFLICT ON CONSTRAINT cnst_unique_website
//	DO UPDATE SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    blacklist = EXCLUDED.blacklist,
//	    whitelist = EXCLUDED.whitelist
//	RETURNING id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at
func (q *Queries) CreateWebsite(ctx context.Context, arg *CreateWebsiteParams) (*Website, error) {
	row := q.db.QueryRow(ctx, createWebsite,
		arg.CustomerID,
		arg.Protocol,
		arg.Domain,
		arg.Blacklist,
		arg.Whitelist,
	)
	var i Website
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Protocol,
		&i.Domain,
		&i.Blacklist,
		&i.Whitelist,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createWebsitePage = `-- name: CreateWebsitePage :one
INSERT INTO website_page (
    customer_id, website_id, url, sha_256, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT ON CONSTRAINT cnst_unique_website_page
DO UPDATE SET
    updated_at = CURRENT_TIMESTAMP,
    is_valid = TRUE
RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, created_at, updated_at
`

type CreateWebsitePageParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	WebsiteID  uuid.UUID `db:"website_id" json:"websiteId"`
	Url        string    `db:"url" json:"url"`
	Sha256     string    `db:"sha_256" json:"sha256"`
	Metadata   []byte    `db:"metadata" json:"metadata"`
}

// CreateWebsitePage
//
//	INSERT INTO website_page (
//	    customer_id, website_id, url, sha_256, metadata
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	ON CONFLICT ON CONSTRAINT cnst_unique_website_page
//	DO UPDATE SET
//	    updated_at = CURRENT_TIMESTAMP,
//	    is_valid = TRUE
//	RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, created_at, updated_at
func (q *Queries) CreateWebsitePage(ctx context.Context, arg *CreateWebsitePageParams) (*WebsitePage, error) {
	row := q.db.QueryRow(ctx, createWebsitePage,
		arg.CustomerID,
		arg.WebsiteID,
		arg.Url,
		arg.Sha256,
		arg.Metadata,
	)
	var i WebsitePage
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WebsiteID,
		&i.Url,
		&i.Sha256,
		&i.IsValid,
		&i.Metadata,
		&i.Summary,
		&i.SummarySha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createWebsitePageVector = `-- name: CreateWebsitePageVector :one
INSERT INTO website_page_vector (
    website_page_id, vector_store_id, customer_id, index, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, website_page_id, vector_store_id, customer_id, index, metadata, created_at
`

type CreateWebsitePageVectorParams struct {
	WebsitePageID uuid.UUID `db:"website_page_id" json:"websitePageId"`
	VectorStoreID uuid.UUID `db:"vector_store_id" json:"vectorStoreId"`
	CustomerID    uuid.UUID `db:"customer_id" json:"customerId"`
	Index         int32     `db:"index" json:"index"`
	Metadata      []byte    `db:"metadata" json:"metadata"`
}

// CreateWebsitePageVector
//
//	INSERT INTO website_page_vector (
//	    website_page_id, vector_store_id, customer_id, index, metadata
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	RETURNING id, website_page_id, vector_store_id, customer_id, index, metadata, created_at
func (q *Queries) CreateWebsitePageVector(ctx context.Context, arg *CreateWebsitePageVectorParams) (*WebsitePageVector, error) {
	row := q.db.QueryRow(ctx, createWebsitePageVector,
		arg.WebsitePageID,
		arg.VectorStoreID,
		arg.CustomerID,
		arg.Index,
		arg.Metadata,
	)
	var i WebsitePageVector
	err := row.Scan(
		&i.ID,
		&i.WebsitePageID,
		&i.VectorStoreID,
		&i.CustomerID,
		&i.Index,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customer
WHERE id = $1
`

// DeleteCustomer
//
//	DELETE FROM customer
//	WHERE id = $1
func (q *Queries) DeleteCustomer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const deleteDocumentsOlderThan = `-- name: DeleteDocumentsOlderThan :exec
DELETE FROM document
WHERE customer_id = $1
AND updated_at < $2
`

type DeleteDocumentsOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// DeleteDocumentsOlderThan
//
//	DELETE FROM document
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) DeleteDocumentsOlderThan(ctx context.Context, arg *DeleteDocumentsOlderThanParams) error {
	_, err := q.db.Exec(ctx, deleteDocumentsOlderThan, arg.CustomerID, arg.UpdatedAt)
	return err
}

const deleteFoldersOlderThan = `-- name: DeleteFoldersOlderThan :exec
DELETE FROM folder
WHERE customer_id = $1
AND updated_at < $2
`

type DeleteFoldersOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// DeleteFoldersOlderThan
//
//	DELETE FROM folder
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) DeleteFoldersOlderThan(ctx context.Context, arg *DeleteFoldersOlderThanParams) error {
	_, err := q.db.Exec(ctx, deleteFoldersOlderThan, arg.CustomerID, arg.UpdatedAt)
	return err
}

const deleteWebsitePagesNotValid = `-- name: DeleteWebsitePagesNotValid :exec
DELETE FROM website_page
WHERE customer_id = $1
AND website_id = $2
AND is_valid = FALSE
`

type DeleteWebsitePagesNotValidParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	WebsiteID  uuid.UUID `db:"website_id" json:"websiteId"`
}

// DeleteWebsitePagesNotValid
//
//	DELETE FROM website_page
//	WHERE customer_id = $1
//	AND website_id = $2
//	AND is_valid = FALSE
func (q *Queries) DeleteWebsitePagesNotValid(ctx context.Context, arg *DeleteWebsitePagesNotValidParams) error {
	_, err := q.db.Exec(ctx, deleteWebsitePagesNotValid, arg.CustomerID, arg.WebsiteID)
	return err
}

const deleteWebsitePagesOlderThan = `-- name: DeleteWebsitePagesOlderThan :exec
DELETE FROM website_page
WHERE customer_id = $1
AND updated_at < $2
`

type DeleteWebsitePagesOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// DeleteWebsitePagesOlderThan
//
//	DELETE FROM website_page
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) DeleteWebsitePagesOlderThan(ctx context.Context, arg *DeleteWebsitePagesOlderThanParams) error {
	_, err := q.db.Exec(ctx, deleteWebsitePagesOlderThan, arg.CustomerID, arg.UpdatedAt)
	return err
}

const getAvailableModel = `-- name: GetAvailableModel :one
SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
WHERE id = $1
`

// GetAvailableModel
//
//	SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
//	WHERE id = $1
func (q *Queries) GetAvailableModel(ctx context.Context, id string) (*AvailableModel, error) {
	row := q.db.QueryRow(ctx, getAvailableModel, id)
	var i AvailableModel
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.DisplayName,
		&i.Description,
		&i.InputTokenLimit,
		&i.OutputTokenLimit,
		&i.Currency,
		&i.InputCostPerMillionTokens,
		&i.OutputCostPerMillionTokens,
		&i.DepreciatedWarning,
		&i.IsDepreciated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAvailableModels = `-- name: GetAvailableModels :many
SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
`

// GetAvailableModels
//
//	SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
func (q *Queries) GetAvailableModels(ctx context.Context) ([]*AvailableModel, error) {
	rows, err := q.db.Query(ctx, getAvailableModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AvailableModel{}
	for rows.Next() {
		var i AvailableModel
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.DisplayName,
			&i.Description,
			&i.InputTokenLimit,
			&i.OutputTokenLimit,
			&i.Currency,
			&i.InputCostPerMillionTokens,
			&i.OutputCostPerMillionTokens,
			&i.DepreciatedWarning,
			&i.IsDepreciated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableModelsScoped = `-- name: GetAvailableModelsScoped :many
SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
WHERE provider = $1
`

// GetAvailableModelsScoped
//
//	SELECT id, provider, display_name, description, input_token_limit, output_token_limit, currency, input_cost_per_million_tokens, output_cost_per_million_tokens, depreciated_warning, is_depreciated, created_at, updated_at FROM available_model
//	WHERE provider = $1
func (q *Queries) GetAvailableModelsScoped(ctx context.Context, provider string) ([]*AvailableModel, error) {
	rows, err := q.db.Query(ctx, getAvailableModelsScoped, provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AvailableModel{}
	for rows.Next() {
		var i AvailableModel
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.DisplayName,
			&i.Description,
			&i.InputTokenLimit,
			&i.OutputTokenLimit,
			&i.Currency,
			&i.InputCostPerMillionTokens,
			&i.OutputCostPerMillionTokens,
			&i.DepreciatedWarning,
			&i.IsDepreciated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversation = `-- name: GetConversation :one
SELECT id, customer_id, title, conversation_type, system_message, metadata, created_at, updated_at FROM conversation
WHERE id = $1
`

// GetConversation
//
//	SELECT id, customer_id, title, conversation_type, system_message, metadata, created_at, updated_at FROM conversation
//	WHERE id = $1
func (q *Queries) GetConversation(ctx context.Context, id uuid.UUID) (*Conversation, error) {
	row := q.db.QueryRow(ctx, getConversation, id)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.ConversationType,
		&i.SystemMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT id, conversation_id, llm_id, model, temperature, instructions, role, message, index, tool_use_id, tool_name, tool_arguments, created_at, updated_at FROM conversation_message
WHERE conversation_id = $1
ORDER BY index ASC
`

// GetConversationMessages
//
//	SELECT id, conversation_id, llm_id, model, temperature, instructions, role, message, index, tool_use_id, tool_name, tool_arguments, created_at, updated_at FROM conversation_message
//	WHERE conversation_id = $1
//	ORDER BY index ASC
func (q *Queries) GetConversationMessages(ctx context.Context, conversationID uuid.UUID) ([]*ConversationMessage, error) {
	rows, err := q.db.Query(ctx, getConversationMessages, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ConversationMessage{}
	for rows.Next() {
		var i ConversationMessage
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.LlmID,
			&i.Model,
			&i.Temperature,
			&i.Instructions,
			&i.Role,
			&i.Message,
			&i.Index,
			&i.ToolUseID,
			&i.ToolName,
			&i.ToolArguments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversations = `-- name: GetConversations :many
SELECT id, customer_id, title, conversation_type, system_message, metadata, created_at, updated_at FROM conversation
WHERE customer_id = $1
`

// GetConversations
//
//	SELECT id, customer_id, title, conversation_type, system_message, metadata, created_at, updated_at FROM conversation
//	WHERE customer_id = $1
func (q *Queries) GetConversations(ctx context.Context, customerID uuid.UUID) ([]*Conversation, error) {
	rows, err := q.db.Query(ctx, getConversations, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Title,
			&i.ConversationType,
			&i.SystemMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsWithCount = `-- name: GetConversationsWithCount :many
SELECT c.id, c.customer_id, c.title, c.conversation_type, c.system_message, c.metadata, c.created_at, c.updated_at, COUNT(cm.id) AS message_count
FROM conversation c
JOIN conversation_message cm
ON c.id = cm.conversation_id
WHERE c.customer_id = $1
GROUP BY c.id
`

type GetConversationsWithCountRow struct {
	ID               uuid.UUID          `db:"id" json:"id"`
	CustomerID       uuid.UUID          `db:"customer_id" json:"customerId"`
	Title            string             `db:"title" json:"title"`
	ConversationType string             `db:"conversation_type" json:"conversationType"`
	SystemMessage    string             `db:"system_message" json:"systemMessage"`
	Metadata         []byte             `db:"metadata" json:"metadata"`
	CreatedAt        pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt        pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	MessageCount     int64              `db:"message_count" json:"messageCount"`
}

// GetConversationsWithCount
//
//	SELECT c.id, c.customer_id, c.title, c.conversation_type, c.system_message, c.metadata, c.created_at, c.updated_at, COUNT(cm.id) AS message_count
//	FROM conversation c
//	JOIN conversation_message cm
//	ON c.id = cm.conversation_id
//	WHERE c.customer_id = $1
//	GROUP BY c.id
func (q *Queries) GetConversationsWithCount(ctx context.Context, customerID uuid.UUID) ([]*GetConversationsWithCountRow, error) {
	rows, err := q.db.Query(ctx, getConversationsWithCount, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetConversationsWithCountRow{}
	for rows.Next() {
		var i GetConversationsWithCountRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Title,
			&i.ConversationType,
			&i.SystemMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, name, datastore, created_at, updated_at FROM customer
WHERE id = $1 LIMIT 1
`

// GetCustomer
//
//	SELECT id, name, datastore, created_at, updated_at FROM customer
//	WHERE id = $1 LIMIT 1
func (q *Queries) GetCustomer(ctx context.Context, id uuid.UUID) (*Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Datastore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getCustomerByName = `-- name: GetCustomerByName :one
SELECT id, name, datastore, created_at, updated_at FROM customer
WHERE name = $1 LIMIT 1
`

// GetCustomerByName
//
//	SELECT id, name, datastore, created_at, updated_at FROM customer
//	WHERE name = $1 LIMIT 1
func (q *Queries) GetCustomerByName(ctx context.Context, name string) (*Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByName, name)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Datastore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getDefaultLLM = `-- name: GetDefaultLLM :one
WITH RequiredLLM AS (
    -- First, try to find a customer-specific default if customer_id is provided
    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
    WHERE llm.customer_id = $1 AND llm.is_default = true

    UNION ALL

    -- Fallback to a global default if no customer-specific default is found
    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
    WHERE llm.customer_id IS NULL AND llm.is_default = true
    AND NOT EXISTS (
        SELECT 1
        FROM llm
        WHERE llm.customer_id = $1 AND llm.is_default = true
    )
)
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
FROM RequiredLLM llm
INNER JOIN available_model am ON am.id = llm.model
LIMIT 1
`

type GetDefaultLLMRow struct {
	ID                         uuid.UUID          `db:"id" json:"id"`
	CustomerID                 pgtype.UUID        `db:"customer_id" json:"customerId"`
	Title                      string             `db:"title" json:"title"`
	Color                      *string            `db:"color" json:"color"`
	Model                      string             `db:"model" json:"model"`
	Temperature                float64            `db:"temperature" json:"temperature"`
	Instructions               string             `db:"instructions" json:"instructions"`
	IsDefault                  bool               `db:"is_default" json:"isDefault"`
	Public                     bool               `db:"public" json:"public"`
	CreatedAt                  pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt                  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	ID_2                       string             `db:"id_2" json:"id2"`
	Provider                   string             `db:"provider" json:"provider"`
	DisplayName                string             `db:"display_name" json:"displayName"`
	Description                string             `db:"description" json:"description"`
	InputTokenLimit            int32              `db:"input_token_limit" json:"inputTokenLimit"`
	OutputTokenLimit           int32              `db:"output_token_limit" json:"outputTokenLimit"`
	Currency                   string             `db:"currency" json:"currency"`
	InputCostPerMillionTokens  pgtype.Numeric     `db:"input_cost_per_million_tokens" json:"inputCostPerMillionTokens"`
	OutputCostPerMillionTokens pgtype.Numeric     `db:"output_cost_per_million_tokens" json:"outputCostPerMillionTokens"`
	DepreciatedWarning         bool               `db:"depreciated_warning" json:"depreciatedWarning"`
	IsDepreciated              bool               `db:"is_depreciated" json:"isDepreciated"`
	CreatedAt_2                pgtype.Timestamptz `db:"created_at_2" json:"createdAt2"`
	UpdatedAt_2                pgtype.Timestamptz `db:"updated_at_2" json:"updatedAt2"`
}

// GetDefaultLLM
//
//	WITH RequiredLLM AS (
//	    -- First, try to find a customer-specific default if customer_id is provided
//	    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
//	    WHERE llm.customer_id = $1 AND llm.is_default = true
//
//	    UNION ALL
//
//	    -- Fallback to a global default if no customer-specific default is found
//	    SELECT id, customer_id, title, color, model, temperature, instructions, is_default, public, created_at, updated_at FROM llm
//	    WHERE llm.customer_id IS NULL AND llm.is_default = true
//	    AND NOT EXISTS (
//	        SELECT 1
//	        FROM llm
//	        WHERE llm.customer_id = $1 AND llm.is_default = true
//	    )
//	)
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at
//	FROM RequiredLLM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	LIMIT 1
func (q *Queries) GetDefaultLLM(ctx context.Context, customerID pgtype.UUID) (*GetDefaultLLMRow, error) {
	row := q.db.QueryRow(ctx, getDefaultLLM, customerID)
	var i GetDefaultLLMRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Color,
		&i.Model,
		&i.Temperature,
		&i.Instructions,
		&i.IsDefault,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Provider,
		&i.DisplayName,
		&i.Description,
		&i.InputTokenLimit,
		&i.OutputTokenLimit,
		&i.Currency,
		&i.InputCostPerMillionTokens,
		&i.OutputCostPerMillionTokens,
		&i.DepreciatedWarning,
		&i.IsDepreciated,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return &i, err
}

const getDocument = `-- name: GetDocument :one
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
WHERE id = $1 LIMIT 1
`

// GetDocument
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
//	WHERE id = $1 LIMIT 1
func (q *Queries) GetDocument(ctx context.Context, id uuid.UUID) (*Document, error) {
	row := q.db.QueryRow(ctx, getDocument, id)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Filename,
		&i.Type,
		&i.SizeBytes,
		&i.Sha256,
		&i.Validated,
		&i.DatastoreType,
		&i.DatastoreID,
		&i.Summary,
		&i.SummarySha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getDocumentsByCustomer = `-- name: GetDocumentsByCustomer :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
WHERE customer_id = $1 AND validated = true
`

// GetDocumentsByCustomer
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
//	WHERE customer_id = $1 AND validated = true
func (q *Queries) GetDocumentsByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getDocumentsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentsFromParent = `-- name: GetDocumentsFromParent :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
WHERE parent_id = $1 AND validated = true
`

// GetDocumentsFromParent
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
//	WHERE parent_id = $1 AND validated = true
func (q *Queries) GetDocumentsFromParent(ctx context.Context, parentID pgtype.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getDocumentsFromParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentsOlderThan = `-- name: GetDocumentsOlderThan :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
WHERE customer_id = $1
AND updated_at < $2
`

type GetDocumentsOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// GetDocumentsOlderThan
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) GetDocumentsOlderThan(ctx context.Context, arg *GetDocumentsOlderThanParams) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getDocumentsOlderThan, arg.CustomerID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFolder = `-- name: GetFolder :one
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE id = $1 LIMIT 1
`

// GetFolder
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE id = $1 LIMIT 1
func (q *Queries) GetFolder(ctx context.Context, id uuid.UUID) (*Folder, error) {
	row := q.db.QueryRow(ctx, getFolder, id)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getFolderWithName = `-- name: GetFolderWithName :one
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE customer_id = $1 AND title = $2
LIMIT 1
`

type GetFolderWithNameParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	Title      string    `db:"title" json:"title"`
}

// GetFolderWithName
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE customer_id = $1 AND title = $2
//	LIMIT 1
func (q *Queries) GetFolderWithName(ctx context.Context, arg *GetFolderWithNameParams) (*Folder, error) {
	row := q.db.QueryRow(ctx, getFolderWithName, arg.CustomerID, arg.Title)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getFoldersByCustomer = `-- name: GetFoldersByCustomer :many
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE customer_id = $1
`

// GetFoldersByCustomer
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE customer_id = $1
func (q *Queries) GetFoldersByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Folder, error) {
	rows, err := q.db.Query(ctx, getFoldersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFoldersFromParent = `-- name: GetFoldersFromParent :many
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE parent_id = $1
`

// GetFoldersFromParent
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE parent_id = $1
func (q *Queries) GetFoldersFromParent(ctx context.Context, parentID pgtype.UUID) ([]*Folder, error) {
	rows, err := q.db.Query(ctx, getFoldersFromParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFoldersOlderThan = `-- name: GetFoldersOlderThan :many
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE customer_id = $1
AND updated_at < $2
`

type GetFoldersOlderThanParams struct {
	CustomerID uuid.UUID          `db:"customer_id" json:"customerId"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// GetFoldersOlderThan
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE customer_id = $1
//	AND updated_at < $2
func (q *Queries) GetFoldersOlderThan(ctx context.Context, arg *GetFoldersOlderThanParams) ([]*Folder, error) {
	rows, err := q.db.Query(ctx, getFoldersOlderThan, arg.CustomerID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInteralLLM = `-- name: GetInteralLLM :one
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
INNER JOIN available_model am ON am.id = llm.model
WHERE title = $1 AND public = false
LIMIT 1
`

type GetInteralLLMRow struct {
	ID                         uuid.UUID          `db:"id" json:"id"`
	CustomerID                 pgtype.UUID        `db:"customer_id" json:"customerId"`
	Title                      string             `db:"title" json:"title"`
	Color                      *string            `db:"color" json:"color"`
	Model                      string             `db:"model" json:"model"`
	Temperature                float64            `db:"temperature" json:"temperature"`
	Instructions               string             `db:"instructions" json:"instructions"`
	IsDefault                  bool               `db:"is_default" json:"isDefault"`
	Public                     bool               `db:"public" json:"public"`
	CreatedAt                  pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt                  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	ID_2                       string             `db:"id_2" json:"id2"`
	Provider                   string             `db:"provider" json:"provider"`
	DisplayName                string             `db:"display_name" json:"displayName"`
	Description                string             `db:"description" json:"description"`
	InputTokenLimit            int32              `db:"input_token_limit" json:"inputTokenLimit"`
	OutputTokenLimit           int32              `db:"output_token_limit" json:"outputTokenLimit"`
	Currency                   string             `db:"currency" json:"currency"`
	InputCostPerMillionTokens  pgtype.Numeric     `db:"input_cost_per_million_tokens" json:"inputCostPerMillionTokens"`
	OutputCostPerMillionTokens pgtype.Numeric     `db:"output_cost_per_million_tokens" json:"outputCostPerMillionTokens"`
	DepreciatedWarning         bool               `db:"depreciated_warning" json:"depreciatedWarning"`
	IsDepreciated              bool               `db:"is_depreciated" json:"isDepreciated"`
	CreatedAt_2                pgtype.Timestamptz `db:"created_at_2" json:"createdAt2"`
	UpdatedAt_2                pgtype.Timestamptz `db:"updated_at_2" json:"updatedAt2"`
}

// GetInteralLLM
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	WHERE title = $1 AND public = false
//	LIMIT 1
func (q *Queries) GetInteralLLM(ctx context.Context, title string) (*GetInteralLLMRow, error) {
	row := q.db.QueryRow(ctx, getInteralLLM, title)
	var i GetInteralLLMRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Color,
		&i.Model,
		&i.Temperature,
		&i.Instructions,
		&i.IsDefault,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Provider,
		&i.DisplayName,
		&i.Description,
		&i.InputTokenLimit,
		&i.OutputTokenLimit,
		&i.Currency,
		&i.InputCostPerMillionTokens,
		&i.OutputCostPerMillionTokens,
		&i.DepreciatedWarning,
		&i.IsDepreciated,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return &i, err
}

const getLLM = `-- name: GetLLM :one
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
INNER JOIN available_model am ON am.id = llm.model
WHERE llm.id = $1
`

type GetLLMRow struct {
	ID                         uuid.UUID          `db:"id" json:"id"`
	CustomerID                 pgtype.UUID        `db:"customer_id" json:"customerId"`
	Title                      string             `db:"title" json:"title"`
	Color                      *string            `db:"color" json:"color"`
	Model                      string             `db:"model" json:"model"`
	Temperature                float64            `db:"temperature" json:"temperature"`
	Instructions               string             `db:"instructions" json:"instructions"`
	IsDefault                  bool               `db:"is_default" json:"isDefault"`
	Public                     bool               `db:"public" json:"public"`
	CreatedAt                  pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt                  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	ID_2                       string             `db:"id_2" json:"id2"`
	Provider                   string             `db:"provider" json:"provider"`
	DisplayName                string             `db:"display_name" json:"displayName"`
	Description                string             `db:"description" json:"description"`
	InputTokenLimit            int32              `db:"input_token_limit" json:"inputTokenLimit"`
	OutputTokenLimit           int32              `db:"output_token_limit" json:"outputTokenLimit"`
	Currency                   string             `db:"currency" json:"currency"`
	InputCostPerMillionTokens  pgtype.Numeric     `db:"input_cost_per_million_tokens" json:"inputCostPerMillionTokens"`
	OutputCostPerMillionTokens pgtype.Numeric     `db:"output_cost_per_million_tokens" json:"outputCostPerMillionTokens"`
	DepreciatedWarning         bool               `db:"depreciated_warning" json:"depreciatedWarning"`
	IsDepreciated              bool               `db:"is_depreciated" json:"isDepreciated"`
	CreatedAt_2                pgtype.Timestamptz `db:"created_at_2" json:"createdAt2"`
	UpdatedAt_2                pgtype.Timestamptz `db:"updated_at_2" json:"updatedAt2"`
}

// GetLLM
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	WHERE llm.id = $1
func (q *Queries) GetLLM(ctx context.Context, id uuid.UUID) (*GetLLMRow, error) {
	row := q.db.QueryRow(ctx, getLLM, id)
	var i GetLLMRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Color,
		&i.Model,
		&i.Temperature,
		&i.Instructions,
		&i.IsDefault,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Provider,
		&i.DisplayName,
		&i.Description,
		&i.InputTokenLimit,
		&i.OutputTokenLimit,
		&i.Currency,
		&i.InputCostPerMillionTokens,
		&i.OutputCostPerMillionTokens,
		&i.DepreciatedWarning,
		&i.IsDepreciated,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return &i, err
}

const getLLMsByCustomer = `-- name: GetLLMsByCustomer :many
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
INNER JOIN available_model am ON am.id = llm.model
WHERE customer_id = $1
`

type GetLLMsByCustomerRow struct {
	ID                         uuid.UUID          `db:"id" json:"id"`
	CustomerID                 pgtype.UUID        `db:"customer_id" json:"customerId"`
	Title                      string             `db:"title" json:"title"`
	Color                      *string            `db:"color" json:"color"`
	Model                      string             `db:"model" json:"model"`
	Temperature                float64            `db:"temperature" json:"temperature"`
	Instructions               string             `db:"instructions" json:"instructions"`
	IsDefault                  bool               `db:"is_default" json:"isDefault"`
	Public                     bool               `db:"public" json:"public"`
	CreatedAt                  pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt                  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	ID_2                       string             `db:"id_2" json:"id2"`
	Provider                   string             `db:"provider" json:"provider"`
	DisplayName                string             `db:"display_name" json:"displayName"`
	Description                string             `db:"description" json:"description"`
	InputTokenLimit            int32              `db:"input_token_limit" json:"inputTokenLimit"`
	OutputTokenLimit           int32              `db:"output_token_limit" json:"outputTokenLimit"`
	Currency                   string             `db:"currency" json:"currency"`
	InputCostPerMillionTokens  pgtype.Numeric     `db:"input_cost_per_million_tokens" json:"inputCostPerMillionTokens"`
	OutputCostPerMillionTokens pgtype.Numeric     `db:"output_cost_per_million_tokens" json:"outputCostPerMillionTokens"`
	DepreciatedWarning         bool               `db:"depreciated_warning" json:"depreciatedWarning"`
	IsDepreciated              bool               `db:"is_depreciated" json:"isDepreciated"`
	CreatedAt_2                pgtype.Timestamptz `db:"created_at_2" json:"createdAt2"`
	UpdatedAt_2                pgtype.Timestamptz `db:"updated_at_2" json:"updatedAt2"`
}

// GetLLMsByCustomer
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	WHERE customer_id = $1
func (q *Queries) GetLLMsByCustomer(ctx context.Context, customerID pgtype.UUID) ([]*GetLLMsByCustomerRow, error) {
	rows, err := q.db.Query(ctx, getLLMsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLLMsByCustomerRow{}
	for rows.Next() {
		var i GetLLMsByCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Title,
			&i.Color,
			&i.Model,
			&i.Temperature,
			&i.Instructions,
			&i.IsDefault,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Provider,
			&i.DisplayName,
			&i.Description,
			&i.InputTokenLimit,
			&i.OutputTokenLimit,
			&i.Currency,
			&i.InputCostPerMillionTokens,
			&i.OutputCostPerMillionTokens,
			&i.DepreciatedWarning,
			&i.IsDepreciated,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkedInPost = `-- name: GetLinkedInPost :one
SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
WHERE id = $1
`

// GetLinkedInPost
//
//	SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
//	WHERE id = $1
func (q *Queries) GetLinkedInPost(ctx context.Context, id uuid.UUID) (*LinkedinPost, error) {
	row := q.db.QueryRow(ctx, getLinkedInPost, id)
	var i LinkedinPost
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectLibraryID,
		&i.ProjectIdeaID,
		&i.Title,
		&i.AssetID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getLinkedInPostConfig = `-- name: GetLinkedInPostConfig :one
WITH LinkedInPostConfig AS (
    -- First, try to find a post-specific config
    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
    WHERE linkedin_post_config.project_id = $1 AND linkedin_post_config.linkedin_post_id = $2

    UNION ALL

    -- Fallback to the project's default
    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
    WHERE linkedin_post_config.project_id = $1 AND linkedin_post_config.linkedin_post_id IS NULL

    UNION ALL
    
    -- Finally fallback to global config
    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
    WHERE linkedin_post_config.project_id IS NULL
)
SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM LinkedInPostConfig
LIMIT 1
`

type GetLinkedInPostConfigParams struct {
	ProjectID      pgtype.UUID `db:"project_id" json:"projectId"`
	LinkedinPostID pgtype.UUID `db:"linkedin_post_id" json:"linkedinPostId"`
}

type GetLinkedInPostConfigRow struct {
	ID                        uuid.UUID          `db:"id" json:"id"`
	ProjectID                 pgtype.UUID        `db:"project_id" json:"projectId"`
	LinkedinPostID            pgtype.UUID        `db:"linkedin_post_id" json:"linkedinPostId"`
	MinSections               int32              `db:"min_sections" json:"minSections"`
	MaxSections               int32              `db:"max_sections" json:"maxSections"`
	NumDocuments              int32              `db:"num_documents" json:"numDocuments"`
	NumWebsitePages           int32              `db:"num_website_pages" json:"numWebsitePages"`
	LlmContentGenerationID    pgtype.UUID        `db:"llm_content_generation_id" json:"llmContentGenerationId"`
	LlmVectorSummarizationID  pgtype.UUID        `db:"llm_vector_summarization_id" json:"llmVectorSummarizationId"`
	LlmWebsiteSummarizationID pgtype.UUID        `db:"llm_website_summarization_id" json:"llmWebsiteSummarizationId"`
	LlmProofReadingID         pgtype.UUID        `db:"llm_proof_reading_id" json:"llmProofReadingId"`
	CreatedAt                 pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt                 pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

// GetLinkedInPostConfig
//
//	WITH LinkedInPostConfig AS (
//	    -- First, try to find a post-specific config
//	    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
//	    WHERE linkedin_post_config.project_id = $1 AND linkedin_post_config.linkedin_post_id = $2
//
//	    UNION ALL
//
//	    -- Fallback to the project's default
//	    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
//	    WHERE linkedin_post_config.project_id = $1 AND linkedin_post_config.linkedin_post_id IS NULL
//
//	    UNION ALL
//
//	    -- Finally fallback to global config
//	    SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM linkedin_post_config
//	    WHERE linkedin_post_config.project_id IS NULL
//	)
//	SELECT id, project_id, linkedin_post_id, min_sections, max_sections, num_documents, num_website_pages, llm_content_generation_id, llm_vector_summarization_id, llm_website_summarization_id, llm_proof_reading_id, created_at, updated_at FROM LinkedInPostConfig
//	LIMIT 1
func (q *Queries) GetLinkedInPostConfig(ctx context.Context, arg *GetLinkedInPostConfigParams) (*GetLinkedInPostConfigRow, error) {
	row := q.db.QueryRow(ctx, getLinkedInPostConfig, arg.ProjectID, arg.LinkedinPostID)
	var i GetLinkedInPostConfigRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.LinkedinPostID,
		&i.MinSections,
		&i.MaxSections,
		&i.NumDocuments,
		&i.NumWebsitePages,
		&i.LlmContentGenerationID,
		&i.LlmVectorSummarizationID,
		&i.LlmWebsiteSummarizationID,
		&i.LlmProofReadingID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getLinkedInPostLibrary = `-- name: GetLinkedInPostLibrary :one
SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
WHERE project_library_id = $1
`

// GetLinkedInPostLibrary
//
//	SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
//	WHERE project_library_id = $1
func (q *Queries) GetLinkedInPostLibrary(ctx context.Context, projectLibraryID uuid.UUID) (*LinkedinPost, error) {
	row := q.db.QueryRow(ctx, getLinkedInPostLibrary, projectLibraryID)
	var i LinkedinPost
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectLibraryID,
		&i.ProjectIdeaID,
		&i.Title,
		&i.AssetID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getLinkedInPosts = `-- name: GetLinkedInPosts :many
SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
WHERE project_id = $1
`

// GetLinkedInPosts
//
//	SELECT id, project_id, project_library_id, project_idea_id, title, asset_id, metadata, created_at, updated_at FROM linkedin_post
//	WHERE project_id = $1
func (q *Queries) GetLinkedInPosts(ctx context.Context, projectID uuid.UUID) ([]*LinkedinPost, error) {
	rows, err := q.db.Query(ctx, getLinkedInPosts, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LinkedinPost{}
	for rows.Next() {
		var i LinkedinPost
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectLibraryID,
			&i.ProjectIdeaID,
			&i.Title,
			&i.AssetID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProject = `-- name: GetProject :one
SELECT id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at FROM project
WHERE id = $1
`

// GetProject
//
//	SELECT id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at FROM project
//	WHERE id = $1
func (q *Queries) GetProject(ctx context.Context, id uuid.UUID) (*Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Title,
		&i.Topic,
		&i.IdeaGenerationModelID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProjectIdea = `-- name: GetProjectIdea :one
SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
WHERE id = $1
`

// GetProjectIdea
//
//	SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
//	WHERE id = $1
func (q *Queries) GetProjectIdea(ctx context.Context, id uuid.UUID) (*ProjectIdea, error) {
	row := q.db.QueryRow(ctx, getProjectIdea, id)
	var i ProjectIdea
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConversationID,
		&i.Title,
		&i.Used,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProjectIdeas = `-- name: GetProjectIdeas :many
SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
WHERE project_id = $1
`

// GetProjectIdeas
//
//	SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
//	WHERE project_id = $1
func (q *Queries) GetProjectIdeas(ctx context.Context, projectID uuid.UUID) ([]*ProjectIdea, error) {
	rows, err := q.db.Query(ctx, getProjectIdeas, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProjectIdea{}
	for rows.Next() {
		var i ProjectIdea
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConversationID,
			&i.Title,
			&i.Used,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectIdeasConversation = `-- name: GetProjectIdeasConversation :many
SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
WHERE conversation_id = $1
ORDER BY created_at DESC
`

// GetProjectIdeasConversation
//
//	SELECT id, project_id, conversation_id, title, used, created_at, updated_at FROM project_idea
//	WHERE conversation_id = $1
//	ORDER BY created_at DESC
func (q *Queries) GetProjectIdeasConversation(ctx context.Context, conversationID pgtype.UUID) ([]*ProjectIdea, error) {
	rows, err := q.db.Query(ctx, getProjectIdeasConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProjectIdea{}
	for rows.Next() {
		var i ProjectIdea
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConversationID,
			&i.Title,
			&i.Used,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectLibrary = `-- name: GetProjectLibrary :many
SELECT id, project_id, title, content_type, draft, published, created_at, updated_at FROM project_library
WHERE project_id = $1
`

// GetProjectLibrary
//
//	SELECT id, project_id, title, content_type, draft, published, created_at, updated_at FROM project_library
//	WHERE project_id = $1
func (q *Queries) GetProjectLibrary(ctx context.Context, projectID uuid.UUID) ([]*ProjectLibrary, error) {
	rows, err := q.db.Query(ctx, getProjectLibrary, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProjectLibrary{}
	for rows.Next() {
		var i ProjectLibrary
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Title,
			&i.ContentType,
			&i.Draft,
			&i.Published,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjects = `-- name: GetProjects :many
SELECT id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at FROM project
WHERE customer_id = $1
`

// GetProjects
//
//	SELECT id, customer_id, title, topic, idea_generation_model_id, created_at, updated_at FROM project
//	WHERE customer_id = $1
func (q *Queries) GetProjects(ctx context.Context, customerID uuid.UUID) ([]*Project, error) {
	rows, err := q.db.Query(ctx, getProjects, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Title,
			&i.Topic,
			&i.IdeaGenerationModelID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootDocumentsByCustomer = `-- name: GetRootDocumentsByCustomer :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
WHERE customer_id = $1 AND parent_id is NULL
`

// GetRootDocumentsByCustomer
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
//	WHERE customer_id = $1 AND parent_id is NULL
func (q *Queries) GetRootDocumentsByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getRootDocumentsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootFoldersByCustomer = `-- name: GetRootFoldersByCustomer :many
SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
WHERE customer_id = $1 AND parent_id IS NULL
`

// GetRootFoldersByCustomer
//
//	SELECT id, parent_id, customer_id, title, created_at, updated_at FROM folder
//	WHERE customer_id = $1 AND parent_id IS NULL
func (q *Queries) GetRootFoldersByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Folder, error) {
	rows, err := q.db.Query(ctx, getRootFoldersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStandardLLMs = `-- name: GetStandardLLMs :many
SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
INNER JOIN available_model am ON am.id = llm.model
where customer_id IS NULL
`

type GetStandardLLMsRow struct {
	ID                         uuid.UUID          `db:"id" json:"id"`
	CustomerID                 pgtype.UUID        `db:"customer_id" json:"customerId"`
	Title                      string             `db:"title" json:"title"`
	Color                      *string            `db:"color" json:"color"`
	Model                      string             `db:"model" json:"model"`
	Temperature                float64            `db:"temperature" json:"temperature"`
	Instructions               string             `db:"instructions" json:"instructions"`
	IsDefault                  bool               `db:"is_default" json:"isDefault"`
	Public                     bool               `db:"public" json:"public"`
	CreatedAt                  pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt                  pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	ID_2                       string             `db:"id_2" json:"id2"`
	Provider                   string             `db:"provider" json:"provider"`
	DisplayName                string             `db:"display_name" json:"displayName"`
	Description                string             `db:"description" json:"description"`
	InputTokenLimit            int32              `db:"input_token_limit" json:"inputTokenLimit"`
	OutputTokenLimit           int32              `db:"output_token_limit" json:"outputTokenLimit"`
	Currency                   string             `db:"currency" json:"currency"`
	InputCostPerMillionTokens  pgtype.Numeric     `db:"input_cost_per_million_tokens" json:"inputCostPerMillionTokens"`
	OutputCostPerMillionTokens pgtype.Numeric     `db:"output_cost_per_million_tokens" json:"outputCostPerMillionTokens"`
	DepreciatedWarning         bool               `db:"depreciated_warning" json:"depreciatedWarning"`
	IsDepreciated              bool               `db:"is_depreciated" json:"isDepreciated"`
	CreatedAt_2                pgtype.Timestamptz `db:"created_at_2" json:"createdAt2"`
	UpdatedAt_2                pgtype.Timestamptz `db:"updated_at_2" json:"updatedAt2"`
}

// GetStandardLLMs
//
//	SELECT llm.id, llm.customer_id, llm.title, llm.color, llm.model, llm.temperature, llm.instructions, llm.is_default, llm.public, llm.created_at, llm.updated_at, am.id, am.provider, am.display_name, am.description, am.input_token_limit, am.output_token_limit, am.currency, am.input_cost_per_million_tokens, am.output_cost_per_million_tokens, am.depreciated_warning, am.is_depreciated, am.created_at, am.updated_at FROM llm
//	INNER JOIN available_model am ON am.id = llm.model
//	where customer_id IS NULL
func (q *Queries) GetStandardLLMs(ctx context.Context) ([]*GetStandardLLMsRow, error) {
	rows, err := q.db.Query(ctx, getStandardLLMs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetStandardLLMsRow{}
	for rows.Next() {
		var i GetStandardLLMsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Title,
			&i.Color,
			&i.Model,
			&i.Temperature,
			&i.Instructions,
			&i.IsDefault,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Provider,
			&i.DisplayName,
			&i.Description,
			&i.InputTokenLimit,
			&i.OutputTokenLimit,
			&i.Currency,
			&i.InputCostPerMillionTokens,
			&i.OutputCostPerMillionTokens,
			&i.DepreciatedWarning,
			&i.IsDepreciated,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenUsage = `-- name: GetTokenUsage :many
SELECT id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens, created_at FROM token_usage
WHERE customer_id = $1
`

// GetTokenUsage
//
//	SELECT id, customer_id, conversation_id, model, input_tokens, output_tokens, total_tokens, created_at FROM token_usage
//	WHERE customer_id = $1
func (q *Queries) GetTokenUsage(ctx context.Context, customerID uuid.UUID) ([]*TokenUsage, error) {
	rows, err := q.db.Query(ctx, getTokenUsage, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TokenUsage{}
	for rows.Next() {
		var i TokenUsage
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ConversationID,
			&i.Model,
			&i.InputTokens,
			&i.OutputTokens,
			&i.TotalTokens,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnvalidatedDocumentsByCustomer = `-- name: GetUnvalidatedDocumentsByCustomer :many
SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
WHERE customer_id = $1 AND validated = false
`

// GetUnvalidatedDocumentsByCustomer
//
//	SELECT id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at FROM document
//	WHERE customer_id = $1 AND validated = false
func (q *Queries) GetUnvalidatedDocumentsByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, getUnvalidatedDocumentsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebsite = `-- name: GetWebsite :one
SELECT id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at FROM website
WHERE id = $1
`

// GetWebsite
//
//	SELECT id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at FROM website
//	WHERE id = $1
func (q *Queries) GetWebsite(ctx context.Context, id uuid.UUID) (*Website, error) {
	row := q.db.QueryRow(ctx, getWebsite, id)
	var i Website
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Protocol,
		&i.Domain,
		&i.Blacklist,
		&i.Whitelist,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getWebsitePagesBySite = `-- name: GetWebsitePagesBySite :many
SELECT id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, created_at, updated_at FROM website_page
WHERE website_id = $1
`

// GetWebsitePagesBySite
//
//	SELECT id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, created_at, updated_at FROM website_page
//	WHERE website_id = $1
func (q *Queries) GetWebsitePagesBySite(ctx context.Context, websiteID uuid.UUID) ([]*WebsitePage, error) {
	rows, err := q.db.Query(ctx, getWebsitePagesBySite, websiteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WebsitePage{}
	for rows.Next() {
		var i WebsitePage
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WebsiteID,
			&i.Url,
			&i.Sha256,
			&i.IsValid,
			&i.Metadata,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebsitesByCustomer = `-- name: GetWebsitesByCustomer :many
SELECT id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at FROM website
WHERE customer_id = $1
`

// GetWebsitesByCustomer
//
//	SELECT id, customer_id, protocol, domain, blacklist, whitelist, created_at, updated_at FROM website
//	WHERE customer_id = $1
func (q *Queries) GetWebsitesByCustomer(ctx context.Context, customerID uuid.UUID) ([]*Website, error) {
	rows, err := q.db.Query(ctx, getWebsitesByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Website{}
	for rows.Next() {
		var i Website
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Protocol,
			&i.Domain,
			&i.Blacklist,
			&i.Whitelist,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, name, datastore, created_at, updated_at FROM customer
ORDER BY name
`

// ListCustomers
//
//	SELECT id, name, datastore, created_at, updated_at FROM customer
//	ORDER BY name
func (q *Queries) ListCustomers(ctx context.Context) ([]*Customer, error) {
	rows, err := q.db.Query(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Datastore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDocumentVectors = `-- name: ListDocumentVectors :many
SELECT id, document_id, vector_store_id, customer_id, index, metadata, created_at FROM document_vector
WHERE customer_id = $1
`

// ListDocumentVectors
//
//	SELECT id, document_id, vector_store_id, customer_id, index, metadata, created_at FROM document_vector
//	WHERE customer_id = $1
func (q *Queries) ListDocumentVectors(ctx context.Context, customerID uuid.UUID) ([]*DocumentVector, error) {
	rows, err := q.db.Query(ctx, listDocumentVectors, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DocumentVector{}
	for rows.Next() {
		var i DocumentVector
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.VectorStoreID,
			&i.CustomerID,
			&i.Index,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebsitePageVectors = `-- name: ListWebsitePageVectors :many
SELECT id, website_page_id, vector_store_id, customer_id, index, metadata, created_at FROM website_page_vector
WHERE customer_id = $1
`

// ListWebsitePageVectors
//
//	SELECT id, website_page_id, vector_store_id, customer_id, index, metadata, created_at FROM website_page_vector
//	WHERE customer_id = $1
func (q *Queries) ListWebsitePageVectors(ctx context.Context, customerID uuid.UUID) ([]*WebsitePageVector, error) {
	rows, err := q.db.Query(ctx, listWebsitePageVectors, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WebsitePageVector{}
	for rows.Next() {
		var i WebsitePageVector
		if err := rows.Scan(
			&i.ID,
			&i.WebsitePageID,
			&i.VectorStoreID,
			&i.CustomerID,
			&i.Index,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDocumentAsUploaded = `-- name: MarkDocumentAsUploaded :one
UPDATE document
SET validated = true
WHERE id = $1
RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at
`

// MarkDocumentAsUploaded
//
//	UPDATE document
//	SET validated = true
//	WHERE id = $1
//	RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at
func (q *Queries) MarkDocumentAsUploaded(ctx context.Context, id uuid.UUID) (*Document, error) {
	row := q.db.QueryRow(ctx, markDocumentAsUploaded, id)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Filename,
		&i.Type,
		&i.SizeBytes,
		&i.Sha256,
		&i.Validated,
		&i.DatastoreType,
		&i.DatastoreID,
		&i.Summary,
		&i.SummarySha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const queryVectorStore = `-- name: QueryVectorStore :many
SELECT
    vs.id, vs.customer_id, vs.raw, vs.embeddings, vs.content_type, vs.object_id, vs.object_parent_id, vs.metadata, vs.created_at, d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.created_at, d.updated_at, wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.created_at, wp.updated_at
FROM vector_store vs
LEFT JOIN document_vector dv ON dv.vector_store_id = vs.object_id
LEFT JOIN document d ON d.id = dv.document_id
LEFT JOIN folder f ON f.id = d.parent_id 
LEFT JOIN website_page_vector wpv ON wpv.vector_store_id = vs.object_id
LEFT JOIN website_page wp ON wp.id = wpv.website_page_id
LEFT JOIN website w ON wp.website_id = w.id
WHERE vs.customer_id = $1
AND (
    (d.id = ANY($4::uuid[]) OR $4 IS NULL)
    OR
    (f.id = ANY($5::uuid[]) OR $5 IS NULL)
    OR
    (wp.id = ANY($6::uuid[]) OR $6 IS NULL)
    OR
    (w.id = ANY($7::uuid[]) OR $7 IS NULL)
)
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
	Column4    []uuid.UUID      `db:"column_4" json:"column4"`
	Column5    []uuid.UUID      `db:"column_5" json:"column5"`
	Column6    []uuid.UUID      `db:"column_6" json:"column6"`
	Column7    []uuid.UUID      `db:"column_7" json:"column7"`
}

type QueryVectorStoreRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	CustomerID      uuid.UUID          `db:"customer_id" json:"customerId"`
	Raw             string             `db:"raw" json:"raw"`
	Embeddings      *pgvector.Vector   `db:"embeddings" json:"embeddings"`
	ContentType     string             `db:"content_type" json:"contentType"`
	ObjectID        uuid.UUID          `db:"object_id" json:"objectId"`
	ObjectParentID  pgtype.UUID        `db:"object_parent_id" json:"objectParentId"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	ID_2            pgtype.UUID        `db:"id_2" json:"id2"`
	ParentID        pgtype.UUID        `db:"parent_id" json:"parentId"`
	CustomerID_2    pgtype.UUID        `db:"customer_id_2" json:"customerId2"`
	Filename        *string            `db:"filename" json:"filename"`
	Type            *string            `db:"type" json:"type"`
	SizeBytes       *int64             `db:"size_bytes" json:"sizeBytes"`
	Sha256          *string            `db:"sha_256" json:"sha256"`
	Validated       *bool              `db:"validated" json:"validated"`
	DatastoreType   *string            `db:"datastore_type" json:"datastoreType"`
	DatastoreID     *string            `db:"datastore_id" json:"datastoreId"`
	Summary         *string            `db:"summary" json:"summary"`
	SummarySha256   *string            `db:"summary_sha_256" json:"summarySha256"`
	CreatedAt_2     pgtype.Timestamptz `db:"created_at_2" json:"createdAt2"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
	ID_3            pgtype.UUID        `db:"id_3" json:"id3"`
	CustomerID_3    pgtype.UUID        `db:"customer_id_3" json:"customerId3"`
	WebsiteID       pgtype.UUID        `db:"website_id" json:"websiteId"`
	Url             *string            `db:"url" json:"url"`
	Sha256_2        *string            `db:"sha_256_2" json:"sha2562"`
	IsValid         *bool              `db:"is_valid" json:"isValid"`
	Metadata_2      []byte             `db:"metadata_2" json:"metadata2"`
	Summary_2       *string            `db:"summary_2" json:"summary2"`
	SummarySha256_2 *string            `db:"summary_sha_256_2" json:"summarySha2562"`
	CreatedAt_3     pgtype.Timestamptz `db:"created_at_3" json:"createdAt3"`
	UpdatedAt_2     pgtype.Timestamptz `db:"updated_at_2" json:"updatedAt2"`
}

// QueryVectorStore
//
//	SELECT
//	    vs.id, vs.customer_id, vs.raw, vs.embeddings, vs.content_type, vs.object_id, vs.object_parent_id, vs.metadata, vs.created_at, d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.created_at, d.updated_at, wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.created_at, wp.updated_at
//	FROM vector_store vs
//	LEFT JOIN document_vector dv ON dv.vector_store_id = vs.object_id
//	LEFT JOIN document d ON d.id = dv.document_id
//	LEFT JOIN folder f ON f.id = d.parent_id
//	LEFT JOIN website_page_vector wpv ON wpv.vector_store_id = vs.object_id
//	LEFT JOIN website_page wp ON wp.id = wpv.website_page_id
//	LEFT JOIN website w ON wp.website_id = w.id
//	WHERE vs.customer_id = $1
//	AND (
//	    (d.id = ANY($4::uuid[]) OR $4 IS NULL)
//	    OR
//	    (f.id = ANY($5::uuid[]) OR $5 IS NULL)
//	    OR
//	    (wp.id = ANY($6::uuid[]) OR $6 IS NULL)
//	    OR
//	    (w.id = ANY($7::uuid[]) OR $7 IS NULL)
//	)
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStore(ctx context.Context, arg *QueryVectorStoreParams) ([]*QueryVectorStoreRow, error) {
	rows, err := q.db.Query(ctx, queryVectorStore,
		arg.CustomerID,
		arg.Limit,
		arg.Embeddings,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QueryVectorStoreRow{}
	for rows.Next() {
		var i QueryVectorStoreRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Raw,
			&i.Embeddings,
			&i.ContentType,
			&i.ObjectID,
			&i.ObjectParentID,
			&i.Metadata,
			&i.CreatedAt,
			&i.ID_2,
			&i.ParentID,
			&i.CustomerID_2,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt_2,
			&i.UpdatedAt,
			&i.ID_3,
			&i.CustomerID_3,
			&i.WebsiteID,
			&i.Url,
			&i.Sha256_2,
			&i.IsValid,
			&i.Metadata_2,
			&i.Summary_2,
			&i.SummarySha256_2,
			&i.CreatedAt_3,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreDocuments = `-- name: QueryVectorStoreDocuments :many
SELECT d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.created_at, d.updated_at
FROM vector_store vs
JOIN document_vector dv ON vs.id = dv.vector_store_id
JOIN document d ON d.id = dv.document_id
WHERE vs.customer_id = $1
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreDocumentsParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
}

// QueryVectorStoreDocuments
//
//	SELECT d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.created_at, d.updated_at
//	FROM vector_store vs
//	JOIN document_vector dv ON vs.id = dv.vector_store_id
//	JOIN document d ON d.id = dv.document_id
//	WHERE vs.customer_id = $1
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreDocuments(ctx context.Context, arg *QueryVectorStoreDocumentsParams) ([]*Document, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreDocuments, arg.CustomerID, arg.Limit, arg.Embeddings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreDocumentsScoped = `-- name: QueryVectorStoreDocumentsScoped :many
SELECT d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.created_at, d.updated_at
FROM vector_store vs
JOIN document_vector dv ON vs.id = dv.vector_store_id
JOIN document d ON d.id = dv.document_id
JOIN folder f ON f.id = d.parent_id
WHERE vs.customer_id = $1
AND (f.id = ANY($4::uuid[]) OR d.id = ANY($5::uuid[]))
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreDocumentsScopedParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
	Column4    []uuid.UUID      `db:"column_4" json:"column4"`
	Column5    []uuid.UUID      `db:"column_5" json:"column5"`
}

// QueryVectorStoreDocumentsScoped
//
//	SELECT d.id, d.parent_id, d.customer_id, d.filename, d.type, d.size_bytes, d.sha_256, d.validated, d.datastore_type, d.datastore_id, d.summary, d.summary_sha_256, d.created_at, d.updated_at
//	FROM vector_store vs
//	JOIN document_vector dv ON vs.id = dv.vector_store_id
//	JOIN document d ON d.id = dv.document_id
//	JOIN folder f ON f.id = d.parent_id
//	WHERE vs.customer_id = $1
//	AND (f.id = ANY($4::uuid[]) OR d.id = ANY($5::uuid[]))
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreDocumentsScoped(ctx context.Context, arg *QueryVectorStoreDocumentsScopedParams) ([]*Document, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreDocumentsScoped,
		arg.CustomerID,
		arg.Limit,
		arg.Embeddings,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CustomerID,
			&i.Filename,
			&i.Type,
			&i.SizeBytes,
			&i.Sha256,
			&i.Validated,
			&i.DatastoreType,
			&i.DatastoreID,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreRaw = `-- name: QueryVectorStoreRaw :many
SELECT id, customer_id, raw, embeddings, content_type, object_id, object_parent_id, metadata, created_at FROM vector_store
WHERE customer_id = $1
ORDER BY embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreRawParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
}

// QueryVectorStoreRaw
//
//	SELECT id, customer_id, raw, embeddings, content_type, object_id, object_parent_id, metadata, created_at FROM vector_store
//	WHERE customer_id = $1
//	ORDER BY embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreRaw(ctx context.Context, arg *QueryVectorStoreRawParams) ([]*VectorStore, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreRaw, arg.CustomerID, arg.Limit, arg.Embeddings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VectorStore{}
	for rows.Next() {
		var i VectorStore
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Raw,
			&i.Embeddings,
			&i.ContentType,
			&i.ObjectID,
			&i.ObjectParentID,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreWebsitePages = `-- name: QueryVectorStoreWebsitePages :many
SELECT wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.created_at, wp.updated_at
FROM vector_store vs
JOIN website_page_vector wpv ON vs.id = wpv.vector_store_id
JOIN website_page wp ON wp.id = wpv.website_page_id
WHERE vs.customer_id = $1
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreWebsitePagesParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
}

// QueryVectorStoreWebsitePages
//
//	SELECT wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.created_at, wp.updated_at
//	FROM vector_store vs
//	JOIN website_page_vector wpv ON vs.id = wpv.vector_store_id
//	JOIN website_page wp ON wp.id = wpv.website_page_id
//	WHERE vs.customer_id = $1
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreWebsitePages(ctx context.Context, arg *QueryVectorStoreWebsitePagesParams) ([]*WebsitePage, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreWebsitePages, arg.CustomerID, arg.Limit, arg.Embeddings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WebsitePage{}
	for rows.Next() {
		var i WebsitePage
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WebsiteID,
			&i.Url,
			&i.Sha256,
			&i.IsValid,
			&i.Metadata,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryVectorStoreWebsitePagesScoped = `-- name: QueryVectorStoreWebsitePagesScoped :many
SELECT wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.created_at, wp.updated_at
FROM vector_store vs
JOIN website_page_vector wpv ON vs.id = wpv.vector_store_id
JOIN website_page wp ON wp.id = wpv.website_page_id
JOIN website w ON w.id = wp.website_id
WHERE vs.customer_id = $1
AND (w.id = ANY($4::uuid[]) OR wp.id = ANY($5::uuid[]))
ORDER BY vs.embeddings <#> $3
LIMIT $2
`

type QueryVectorStoreWebsitePagesScopedParams struct {
	CustomerID uuid.UUID        `db:"customer_id" json:"customerId"`
	Limit      int32            `db:"limit" json:"limit"`
	Embeddings *pgvector.Vector `db:"embeddings" json:"embeddings"`
	Column4    []uuid.UUID      `db:"column_4" json:"column4"`
	Column5    []uuid.UUID      `db:"column_5" json:"column5"`
}

// QueryVectorStoreWebsitePagesScoped
//
//	SELECT wp.id, wp.customer_id, wp.website_id, wp.url, wp.sha_256, wp.is_valid, wp.metadata, wp.summary, wp.summary_sha_256, wp.created_at, wp.updated_at
//	FROM vector_store vs
//	JOIN website_page_vector wpv ON vs.id = wpv.vector_store_id
//	JOIN website_page wp ON wp.id = wpv.website_page_id
//	JOIN website w ON w.id = wp.website_id
//	WHERE vs.customer_id = $1
//	AND (w.id = ANY($4::uuid[]) OR wp.id = ANY($5::uuid[]))
//	ORDER BY vs.embeddings <#> $3
//	LIMIT $2
func (q *Queries) QueryVectorStoreWebsitePagesScoped(ctx context.Context, arg *QueryVectorStoreWebsitePagesScopedParams) ([]*WebsitePage, error) {
	rows, err := q.db.Query(ctx, queryVectorStoreWebsitePagesScoped,
		arg.CustomerID,
		arg.Limit,
		arg.Embeddings,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WebsitePage{}
	for rows.Next() {
		var i WebsitePage
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WebsiteID,
			&i.Url,
			&i.Sha256,
			&i.IsValid,
			&i.Metadata,
			&i.Summary,
			&i.SummarySha256,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setProjectIdeaUsed = `-- name: SetProjectIdeaUsed :one
UPDATE project_idea
    SET used = true
WHERE id = $1
RETURNING id, project_id, conversation_id, title, used, created_at, updated_at
`

// SetProjectIdeaUsed
//
//	UPDATE project_idea
//	    SET used = true
//	WHERE id = $1
//	RETURNING id, project_id, conversation_id, title, used, created_at, updated_at
func (q *Queries) SetProjectIdeaUsed(ctx context.Context, id uuid.UUID) (*ProjectIdea, error) {
	row := q.db.QueryRow(ctx, setProjectIdeaUsed, id)
	var i ProjectIdea
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConversationID,
		&i.Title,
		&i.Used,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const setWebsitePagesNotValid = `-- name: SetWebsitePagesNotValid :exec
UPDATE website_page SET is_valid = FALSE
WHERE customer_id = $1
AND website_id = $2
`

type SetWebsitePagesNotValidParams struct {
	CustomerID uuid.UUID `db:"customer_id" json:"customerId"`
	WebsiteID  uuid.UUID `db:"website_id" json:"websiteId"`
}

// SetWebsitePagesNotValid
//
//	UPDATE website_page SET is_valid = FALSE
//	WHERE customer_id = $1
//	AND website_id = $2
func (q *Queries) SetWebsitePagesNotValid(ctx context.Context, arg *SetWebsitePagesNotValidParams) error {
	_, err := q.db.Exec(ctx, setWebsitePagesNotValid, arg.CustomerID, arg.WebsiteID)
	return err
}

const updateCustomer = `-- name: UpdateCustomer :exec
UPDATE customer
    set name = $2
WHERE id = $1
RETURNING id, name, datastore, created_at, updated_at
`

type UpdateCustomerParams struct {
	ID   uuid.UUID `db:"id" json:"id"`
	Name string    `db:"name" json:"name"`
}

// UpdateCustomer
//
//	UPDATE customer
//	    set name = $2
//	WHERE id = $1
//	RETURNING id, name, datastore, created_at, updated_at
func (q *Queries) UpdateCustomer(ctx context.Context, arg *UpdateCustomerParams) error {
	_, err := q.db.Exec(ctx, updateCustomer, arg.ID, arg.Name)
	return err
}

const updateDocumentSummary = `-- name: UpdateDocumentSummary :one
UPDATE document SET
    summary = $2,
    summary_sha_256 = $3
WHERE id = $1
RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at
`

type UpdateDocumentSummaryParams struct {
	ID            uuid.UUID `db:"id" json:"id"`
	Summary       string    `db:"summary" json:"summary"`
	SummarySha256 string    `db:"summary_sha_256" json:"summarySha256"`
}

// UpdateDocumentSummary
//
//	UPDATE document SET
//	    summary = $2,
//	    summary_sha_256 = $3
//	WHERE id = $1
//	RETURNING id, parent_id, customer_id, filename, type, size_bytes, sha_256, validated, datastore_type, datastore_id, summary, summary_sha_256, created_at, updated_at
func (q *Queries) UpdateDocumentSummary(ctx context.Context, arg *UpdateDocumentSummaryParams) (*Document, error) {
	row := q.db.QueryRow(ctx, updateDocumentSummary, arg.ID, arg.Summary, arg.SummarySha256)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.CustomerID,
		&i.Filename,
		&i.Type,
		&i.SizeBytes,
		&i.Sha256,
		&i.Validated,
		&i.DatastoreType,
		&i.DatastoreID,
		&i.Summary,
		&i.SummarySha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateWebsitePageSignature = `-- name: UpdateWebsitePageSignature :one
UPDATE website_page SET
    sha_256 = $2
WHERE id = $1
RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, created_at, updated_at
`

type UpdateWebsitePageSignatureParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	Sha256 string    `db:"sha_256" json:"sha256"`
}

// UpdateWebsitePageSignature
//
//	UPDATE website_page SET
//	    sha_256 = $2
//	WHERE id = $1
//	RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, created_at, updated_at
func (q *Queries) UpdateWebsitePageSignature(ctx context.Context, arg *UpdateWebsitePageSignatureParams) (*WebsitePage, error) {
	row := q.db.QueryRow(ctx, updateWebsitePageSignature, arg.ID, arg.Sha256)
	var i WebsitePage
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WebsiteID,
		&i.Url,
		&i.Sha256,
		&i.IsValid,
		&i.Metadata,
		&i.Summary,
		&i.SummarySha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateWebsitePageSummary = `-- name: UpdateWebsitePageSummary :one
UPDATE website_page SET
    summary = $2,
    summary_sha_256 = $3
WHERE id = $1
RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, created_at, updated_at
`

type UpdateWebsitePageSummaryParams struct {
	ID            uuid.UUID `db:"id" json:"id"`
	Summary       string    `db:"summary" json:"summary"`
	SummarySha256 string    `db:"summary_sha_256" json:"summarySha256"`
}

// UpdateWebsitePageSummary
//
//	UPDATE website_page SET
//	    summary = $2,
//	    summary_sha_256 = $3
//	WHERE id = $1
//	RETURNING id, customer_id, website_id, url, sha_256, is_valid, metadata, summary, summary_sha_256, created_at, updated_at
func (q *Queries) UpdateWebsitePageSummary(ctx context.Context, arg *UpdateWebsitePageSummaryParams) (*WebsitePage, error) {
	row := q.db.QueryRow(ctx, updateWebsitePageSummary, arg.ID, arg.Summary, arg.SummarySha256)
	var i WebsitePage
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WebsiteID,
		&i.Url,
		&i.Sha256,
		&i.IsValid,
		&i.Metadata,
		&i.Summary,
		&i.SummarySha256,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
